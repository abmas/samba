#!/bin/bash

#set -e
#exit_function()
#{
#
#}


#
# ask_retry "<cmd>"
# NULL/Empty command would cause just the prompt. Skip/Abort out of the prompt as needed.
#
env APPSETUP="/var/tmp/build/bin/appsetup"
ask_retry()
{
    cmd="$1"
    while true; do
        if [ "$cmd" != "" ]; then
            echo "Executing \"$cmd\""
            $1 && return $?
            echo -n "Command failed. Do you wish to (r)etry, (a)bort, (s)kip? : "
        else
            echo -n "Do you wish to (r)etry, (a)bort, (s)kip? : "
        fi
	if [ "$EXIT_ON_ERROR" = "0" ]; then
	    # if EXIT_ON_ERROR" is not defined, we will still abort.
	    read wish
	else
	    wish="a"
	fi
            case "$wish" in
            "r")
                echo "Continuing..."
		continue
                ;;
            "s")
                echo "Skipping..."
		break
                ;;
            "a")
                echo "Exiting..."
		exit 1
                ;;
            *)
                # Wrong input: Play it safe and try again rather than quiting
		echo "Illegal input, Continuing..."
		continue
                ;;
            esac
    done
}

get_samba_specific_defines()
{

    echo "Collecting information required for Samba configuration..."
    echo
    echo
    if [ "$DOMAIN_NAME" = "" ]; then
        echo -n "Please enter the FQDN Windows domain name (example: SL-HyperV.us-east02.simplivt.local): "
        read DOMAIN_NAME
        echo Windows domain name is: $DOMAIN_NAME
        GROUP_NAME="`echo $DOMAIN_NAME | sed "s/\..*//g"`"
        echo Windows workgroup name is: $GROUP_NAME
        echo
    else
        GROUP_NAME="`echo $DOMAIN_NAME | sed "s/\..*//g"`"
    fi

    if [ "$DOMAIN_AD_IP" = "" ]; then
        echo -n "Please enter the Windows domain controller IP address: "
        read DOMAIN_AD_IP
        echo Windows domain controller IP address is: $DOMAIN_AD_IP
        echo
    fi

    if [ "$ADMIN_USER" = "" ]; then
        echo -n "Please provide a domain user name with Admin privileges (just the user name): "
        read ADMIN_USER
        echo Admin domain user is: $ADMIN_USER
        echo
    fi

    if [ "$ADMIN_PASSWD" = "" ]; then
        echo -n "Please enter the password for above ($DOMAIN_NAME :: $ADMIN_USER) user: "
        read ADMIN_PASSWD
        echo
    fi

    if [ "$DVM_NAME" = "" ]; then
        echo -n "Please enter a new name for this DVM or hit enter to keep current name: "
        read DVM_NAME
        [ "$DVM_NAME" = "" ] && DVM_NAME="`hostname`"
        echo DVM name will be $DVM_NAME
        echo
    fi

    if [ "$FAILURE_DOMAIN" = "" ]; then
        echo -n "Please enter a failure domain name for this DVM: "
        read FAILURE_DOMAIN
        echo Failure domain is $FAILURE_DOMAIN
        echo
    fi

    if [ "$HYPERV_HOST_MGMT_IP" = "" ]; then
        echo -n "Please enter the HyperV host management IP address: "
        read HYPERV_HOST_MGMT_IP
        echo Failure domain is $HYPERV_HOST_MGMT_IP
        echo
    fi

    if [ "$SVA_STORAGE_IP" = "" ]; then
        echo -n "Please enter the DVM's storage IP address: "
        read SVA_STORAGE_IP
        echo Failure domain is $SVA_STORAGE_IP
        echo
    fi

}

setup_domain_networking()
{

    echo "Setting up Domain networking config..."
    echo
    echo

    # Update hostname
    if [ "$DVM_NAME" != "" ]
    then
        [ `grep -c $DVM_NAME /etc/hostname` -eq 0 ] && echo $DVM_NAME > /etc/hostname
        hostname $DVM_NAME
    fi

    cp /etc/hosts /etc/hosts.saved.$$
    grep -v "127.0.1.1" /etc/hosts > /tmp/hosts.$$
    sed -i "/127.0.0.1.*$/c\127.0.0.1 $DVM_NAME.$DOMAIN_NAME $DVM_NAME localhost" /tmp/hosts.$$
    mv -f /tmp/hosts.$$ /etc/hosts

    grep -qi "$DOMAIN_NAME" /etc/network/interfaces
    if [ $? -ne 0 ]; then
      cp /etc/network/interfaces /etc/network/interfaces.$$
      sed -i "/dns-nameservers.*/a\ \ \ \ dns-search $DOMAIN_NAME" /etc/network/interfaces
      pushd /etc/resolvconf/resolv.conf.d/
      rm -f original base 2>&1 >/dev/null
      echo "search $DOMAIN_NAME" > original
      popd
      resolvconf -u
    fi

    echo "Updated DNS lookup configuration."
    echo "Trying to create DNS record on the DC $DOMAIN_AD_IP ..."
    success=0
    # Assumption here is eth0 has already been setup with the right management IP.
    DVM_IP=`ifconfig eth0 | grep "inet addr" | awk '{print $2}' | cut -d: -f2`
    if [ "$DOMAIN_AD_IP" != "" -a -f ${SRCPATH}/winexe ]; then
        echo -n "Running: dnscmd ${DOMAIN_AD_IP} /recordadd ${DOMAIN_NAME} ${DVM_NAME}.${DOMAIN_NAME}      A $DVM_IP :on the DC"
	CMD=`echo Powershell.exe  -command "dnscmd ${DOMAIN_AD_IP} /recordadd ${DOMAIN_NAME} ${DVM_NAME} A $DVM_IP"`
        ${SRCPATH}/winexe -U ${ADMIN_USER}%${ADMIN_PASSWD} //${DOMAIN_AD_IP} "$CMD" | grep -qi -e successfully -e _ALREADY_EXISTS
        if [ $? -eq 0 ]; then
            echo " : success"
            success=1
        else
            echo " : failed"
            success=0
        fi

        # Add the failure domain's UNC for share name registration to the AD
        echo -n "Running: dnscmd ${DOMAIN_AD_IP} /recordadd ${DOMAIN_NAME} ${FAILURE_DOMAIN}-omnicube-io  A $DVM_IP :on the DC"
        CMD=`echo Powershell.exe  -command "dnscmd ${DOMAIN_AD_IP} /recordadd ${DOMAIN_NAME} "${FAILURE_DOMAIN}"""-omnicube-io"""" A $DVM_IP"`
echo "CMD $CMD"
        ${SRCPATH}/winexe -U ${ADMIN_USER}%${ADMIN_PASSWD} //${DOMAIN_AD_IP} "$CMD" | grep -qi -e successfully -e _ALREADY_EXISTS
        if [ $? -eq 0 ]; then
            echo " : success"
            success=1
        else
            echo " : failed"
            success=0
        fi

        # Note that this assumes the reverse lookup zone is being setup for the eth0 subnet.
        set `echo $DVM_IP | sed 's/\./ /g'`
        echo -n "Running: dnscmd ${DOMAIN_AD_IP} /zoneadd ${3}.${2}.${1}.in-addr.arpa /primary :on the DC"
	CMD=`echo Powershell.exe  -command "dnscmd ${DOMAIN_AD_IP} /zoneadd ${3}.${2}.${1}.in-addr.arpa /primary"`
        ${SRCPATH}/winexe -U ${ADMIN_USER}%${ADMIN_PASSWD} //${DOMAIN_AD_IP} "$CMD" | grep -qi -e successfully -e _ALREADY_EXISTS
        if [ $? -eq 0 ]; then
            echo " : success"
            success=1
        else
            echo " : failed"
            success=0
        fi
        echo -n "Running: dnscmd ${DOMAIN_AD_IP} /recordadd ${3}.${2}.${1}.in-addr.arpa ${4} PTR ${DVM_NAME} :on the DC"
	CMD=`echo Powershell.exe  -command "dnscmd ${DOMAIN_AD_IP} /recordadd ${3}.${2}.${1}.in-addr.arpa ${4} PTR ${DVM_NAME}"`
        ${SRCPATH}/winexe -U ${ADMIN_USER}%${ADMIN_PASSWD} //${DOMAIN_AD_IP} "$CMD" |  grep -qi -e successfully -e _ALREADY_EXISTS
        if [ $? -eq 0 ]; then
            echo " : success"
            success=1
        else
            echo " : failed"
            success=0
        fi

        # Add failure domain PTR record
        echo -n "Running: dnscmd ${DOMAIN_AD_IP} /recordadd ${3}.${2}.${1}.in-addr.arpa ${4} PTR ${FAILURE_DOMAIN}-omnicube-io.${DOMAIN_NAME} :on the DC"
        CMD=`echo Powershell.exe  -command "dnscmd ${DOMAIN_AD_IP} /recordadd ${3}.${2}.${1}.in-addr.arpa ${4} PTR "${FAILURE_DOMAIN}"""-omnicube-io""".${DOMAIN_NAME}""`
        ${SRCPATH}/winexe -U ${ADMIN_USER}%${ADMIN_PASSWD} //${DOMAIN_AD_IP} "$CMD" |  grep -qi -e successfully -e _ALREADY_EXISTS
        if [ $? -eq 0 ]; then
            echo " : success"
            success=1
        else
            echo " : failed"
            success=0
        fi
    fi
    if [ $success -eq 0 ]; then
        echo "Scripted DNS record creation failed..."
        echo "Now please add a static DNS record"
        echo "for this DVM ($DVM_NAME) on the domain controller, then come back to continue."
        echo -n Hit enter when ready:
        read DUMMY_INPUT
    fi
    echo Testing DNS lookup...
    ask_retry "nslookup $DVM_NAME"

    echo Sync time with domain controller...
    ask_retry "ntpdate -u $DOMAIN_NAME"

    # Remove any old failure domain entry from the HyperV host's hosts file.
    CMD=`echo Powershell.exe  -command '$hosts = get-content C:\Windows\System32\drivers\etc\hosts ; $hosts -notmatch '"\"\"\"\s${FAILURE_DOMAIN}-omnicube-io($|\s)\"\"\""' | Out-File C:\Windows\System32\drivers\etc\hosts'`
    echo -n "Running: $CMD :on the HyperV host"
    ${SRCPATH}/winexe -U ${GROUP_NAME}/${ADMIN_USER}%${ADMIN_PASSWD} //${HYPERV_HOST_MGMT_IP} "$CMD"

    if [ $? -eq 0 ]; then
        echo " : success"
        success=1
    else
        echo " : failed"
        success=0
    fi

    # Add an entry for the failure domain (pointing to the SVA storage IP address) in the
    # HyperV host's hosts file

    CMD=`echo Powershell.exe  -command "\"\"\"${SVA_STORAGE_IP} ${FAILURE_DOMAIN}-omnicube-io\"\"\" | Out-File -append C:\Windows\System32\drivers\etc\hosts"`
    echo -n "Running: $CMD :on the HyperV host"
    ${SRCPATH}/winexe -U ${GROUP_NAME}/${ADMIN_USER}%${ADMIN_PASSWD} //${HYPERV_HOST_MGMT_IP} "$CMD"

    if [ $? -eq 0 ]; then
        echo " : success"
        success=1
    else
        echo " : failed"
        success=0
    fi

}

deploy_samba()
{
    . "$APPSETUP"

    get_samba_specific_defines

    setup_domain_networking

    echo Starting to update Samba on the DVM and integrate with Windows domain...
    echo

    echo Checking for existing samba installation
    dpkg -l | grep -q " samba "

    if [ $? -ne 0 ]; then
        echo "Samba is not already installed, performing apt-get install samba winbind libnss-winbind samba-vfs-modules"
        sudo apt-get -f -y install samba && sudo apt-get -f -y install winbind && sudo apt-get -f -y install libnss-winbind && sudo apt-get install samba-vfs-modules
        if [ $? -eq 0 ]; then
            echo "Failed to install Samba and winbind"
        fi
    else
        echo "Currently installed samba version is `dpkg -l | grep " samba " | awk '{print $3}' | cut -d: -f2`"
        #echo "If you wish to update it, update and then 'skip' below"
        #ask_retry ""
    fi


    # Update smb config
    SMB_CONF=/etc/samba/smb.conf
    sed -i "s/netbios name.*/netbios name = $DVM_NAME/g" $SMB_CONF
    sed -i "s/realm.*/realm = $DOMAIN_NAME/" $SMB_CONF
    sed -i "s/workgroup.*/workgroup = $GROUP_NAME/" $SMB_CONF
    sed -i "s/failure domain name.*/failure domain name = $FAILURE_DOMAIN/" $SMB_CONF

    # copy over the startup scripts, these are done by the deb package now. no need to do them
    # here.
    #\cp -f ${SRCPATH}/samba /etc/init.d/
    #\cp -f ${SRCPATH}/smbd /etc/init.d/

    echo Setting up the domain name...
    domainname $DOMAIN_NAME

    echo Joining domain
    ask_retry "net ads join -U $ADMIN_USER%$ADMIN_PASSWD"

    #TODO Setup so Samba and Winbind start automatically after svtfs.

    /etc/init.d/samba stop
    /etc/init.d/samba start

    echo -n "Waiting for Samba service to start...60 seconds: "
    for i in `seq 1 60`
    do
       sleep 1
       echo -n "."
    done
    echo "Done waiting!"

    echo "Verifying winbind operation..."
    ask_retry "id $ADMIN_USER"

    net rpc rights grant '$GROUP_NAME\\Domain Admins' SeDiskOperatorPrivilege -U$ADMIN_USER%$ADMIN_PASSWD

    # Delete the upstart override file for samba when running on HyperV
    [ `grep -ic provider.hyperv $SVTCONF` -eq 1 ] && (rm /etc/init/svt-samba-server.override)

    echo "SVT Samba One-time Initialization done."
}

add_svtshare()
{

    cat << EOT >> /etc/samba/smb.conf

[svtshare]
        path = /var/tmp/share
        read only = No
        create mask = 0777
        force create mode = 0777
        directory mask = 02777
        directory mode = 02777
        force directory mode = 02777
        kernel share modes = no
        kernel oplocks = no
        posix locking = no
        durable handles = yes
EOT
    dstore_path=/var/tmp/share
    mkdir -p $dstore_path
    #Fix up some permissions on the share path
    # If the below steps fail, restart svtfs from another window and retry here.
    ask_retry "chmod -R 777 $dstore_path"
    echo chown "$ADMIN_USER:domain admins" $dstore_path
    chown "$ADMIN_USER:domain admins" $dstore_path
    # Give permissions to all domain computers. Eventually we want to control the actual permission (rwx) as well as
    # restrict to the computers/nodes in the failure domain.
    echo setfacl -R -m g:"Domain Computers":rwx $dstore_path
    setfacl -R -m g:"Domain Computers":rwx $dstore_path

    /etc/init.d/samba reload

    echo "Share \\\\$DVM_NAME\svtshare is all ready. Map the share from the DC and add Interitable Full Control permission to HyperV host(s). Then, enjoy running HyperV VMs over Samba!"

}

deploy()
{
    deploy_samba
}

print_help_and_exit()
{
    echo "svt-samba-init [ help | status | prep | {one-time-initialization | oti} ]"
    echo " Help for svt-samba-init. If running for the first time, please run 'prep', edit DEFS file"
    echo " with values specific to your installation, and then run with option 'oti'. Execute with "
    echo " option 'status' to see what steps have already been run."
    echo "    help                       : This help text."
    echo "    status                     : Print status of the Samba installation and return."
    echo "    prep                       : Setup common files for DVM and SVA installs."
    echo "    one-time-initialization    : Perform a one time init of samba."
    echo "    oti                        : Same as one-time-initialization."
    exit 0
}

print_status_and_exit()
{
    # Unimplemented.
    exit 0
}

prep_predeploy_and_exit()
{
    if [ ! -d ${SRCPATH} ]; then
        mkdir ${SRCPATH}
        cd ${SRCPATH}
	wget -N http://10.0.0.85/captures/SierraNevada/checkit
	wget -N http://10.0.0.85/captures/SierraNevada/runCheck
	wget -N http://10.0.0.85/captures/SierraNevada/memread
	wget -N http://10.0.0.85/captures/SierraNevada/resetTia
	wget -N http://10.0.0.85/captures/SierraNevada/winexe
	chmod +x winexe
	cat > DEFS << EOT
### Fill these out to avoid fat fingering! Examples are provided as comments (#) below.
### This file is sourced into bash at the beginning of the install script.

####Samba specific definitions START####
#DVM_NAME=ph1 # Note that this is the DNS hostname of the DVM (not the name given to the VM in HyperV).
DVM_NAME=

#DOMAIN_NAME=rama.HyperV.local
DOMAIN_NAME=

#GROUP_NAME=rama (from rama.HyperV.local)
GROUP_NAME=

#DOMAIN_AD_IP=10.149.50.65
DOMAIN_AD_IP=

#ADMIN_USER=Administrator
ADMIN_USER=

#ADMIN_PASSWD=svtrfs29LAB
ADMIN_PASSWD=

#FAILURE_DOMAIN=fd-vdi (unique name for this failure domain)
FAILURE_DOMAIN=

#HYPERV_HOST_MGMT_IP=10.149.10.1
HYPERV_HOST_MGMT_IP=

#SVA_STORAGE_IP=172.31.12.1
SVA_STORAGE_IP=

# Exit on error (automated installs, no retry prompt), change this to
# 0 for manual installs
EXIT_ON_ERROR=1

####Samba specific definitions END####
EOT
    fi

    if [ ! -d ${SAMBAPDIR}/samba ]; then
	mv /var/lib/samba ${SAMBAPDIR}/
	ln -s ${SAMBAPDIR}/samba /var/lib/
	mv /etc/samba/*  ${SAMBAPDIR}/samba/
	rmdir /etc/samba
	ln -s ${SAMBAPDIR}/samba/ /etc/
    fi

    # Update nsswitch.conf
    [ -f /etc/nsswitch.conf ] && cp /etc/nsswitch.conf /etc/nsswitch.conf.orig

    cat /etc/nsswitch.conf | sed 's/\([p|g].*compat\)/\1 winbind/' > /tmp/.nsswitch.$$
    mv -f /tmp/.nsswitch.$$ /etc/nsswitch.conf

    ln -s /lib/x86_64-linux-gnu/libnss_winbind.so.2 /lib/x86_64-linux-gnu/libnss_winbind.so

    ldconfig

    exit 0
}

parse_args()
{

    # No arguments means print help
    [ $# -ne 1 ] && print_help_and_exit

    # As the script currently stands, there can be only 0 or 1 arguments to the script.
    # we still do the for loop below (and shift) to keep the logic generic.
    for i in "$@"
    do
        case $i in
	    help )
		shift
		print_help_and_exit
		;;
	    status )
		shift
		print_status_and_exit
		;;
	    prep )
		shift
		prep_predeploy_and_exit
		;;
	    one-time-initialization | oti )
		shift
		# DO not exit and continue with rest of script
		break
		;;
	    * )
		shift
		print_help_and_exit
		;;
	esac
    done
}

################################# Begin of main routine #########################

#trap exit_function EXIT

SAMBAPDIR="/var/svtfs"
SRCPATH="${SAMBAPDIR}/SambaInstall"

if [ "$EUID" != "0" ]; then
    echo "You must run this script as EUID 0"
    exit 1
fi

parse_args $@

if [ ! -d ${SRCPATH} ]; then
    echo "Needed binaries not available. Please run with 'prep' option first"
    exit 1
fi

cd $SRCPATH

if [ -f ${SRCPATH}/DEFS ]; then
   source ${SRCPATH}/DEFS
fi


if [  -f ${SRCPATH}/runCheck ]; then
   echo "Running runCheck script to check sanity of system..."
   bash ${SRCPATH}/runCheck
   echo
   echo
   if [ "$EXIT_ON_ERROR" = "0" ]; then
      # if EXIT_ON_ERROR" is not defined, we will still abort.
      echo -n "Press any key to continue, Control+C to abort:"
      read wish
   fi
fi

deploy
