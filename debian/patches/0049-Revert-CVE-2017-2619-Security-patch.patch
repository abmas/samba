From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Wed, 3 May 2017 14:27:22 -0400
Subject: Revert "CVE-2017-2619: Security patch"

This reverts commit c96c63d6b4b9de42224a5fb112a9e721f0de3391.
---
 selftest/target/Samba3.pm                 |  25 ---
 source3/script/tests/test_smbclient_s3.sh | 111 -----------
 source3/smbd/dir.c                        | 148 ++++----------
 source3/smbd/filename.c                   |   2 +-
 source3/smbd/open.c                       | 309 +++---------------------------
 source3/smbd/proto.h                      |   4 +-
 source3/smbd/smb2_query_directory.c       |  17 --
 source3/smbd/vfs.c                        |  40 +---
 source4/torture/smb2/dir.c                |  12 +-
 9 files changed, 68 insertions(+), 600 deletions(-)

diff --git a/selftest/target/Samba3.pm b/selftest/target/Samba3.pm
index d2b8b1f..8ff1e7c 100755
--- a/selftest/target/Samba3.pm
+++ b/selftest/target/Samba3.pm
@@ -1173,9 +1173,6 @@ sub provision($$$$$$$$)
 	my $shadow_shrdir="$shadow_basedir/share";
 	push(@dirs,$shadow_shrdir);
 
-	my $nosymlinks_shrdir="$shrdir/nosymlinks";
-	push(@dirs,$nosymlinks_shrdir);
-
 	# this gets autocreated by winbindd
 	my $wbsockdir="$prefix_abs/winbindd";
 	my $wbsockprivdir="$lockdir/winbindd_privileged";
@@ -1683,28 +1680,6 @@ sub provision($$$$$$$$)
 	vfs objects = fake_dfq
 	admin users = $unix_name
 	include = $dfqconffile
-[dfq_owner]
-	path = $shrdir/dfree
-	vfs objects = acl_xattr fake_acls xattr_tdb fake_dfq
-	inherit owner = yes
-	include = $dfqconffile
-
-[acl_xattr_ign_sysacl_posix]
-	copy = tmp
-	acl_xattr:ignore system acls = yes
-	acl_xattr:default acl style = posix
-[acl_xattr_ign_sysacl_windows]
-	copy = tmp
-	acl_xattr:ignore system acls = yes
-	acl_xattr:default acl style = windows
-[nosymlinks]
-	copy = tmp
-	path = $nosymlinks_shrdir
-	follow symlinks = no
-[kernel_oplocks]
-	copy = tmp
-	kernel oplocks = yes
-	vfs objects = streams_xattr xattr_tdb
 	";
 	close(CONF);
 
diff --git a/source3/script/tests/test_smbclient_s3.sh b/source3/script/tests/test_smbclient_s3.sh
index 0694e1b..5e3db5d 100755
--- a/source3/script/tests/test_smbclient_s3.sh
+++ b/source3/script/tests/test_smbclient_s3.sh
@@ -1071,113 +1071,6 @@ done
 
 LOGDIR=$(mktemp -d ${PREFIX}/${LOGDIR_PREFIX}_XXXXXX)
 
-# Test follow symlinks can't access symlinks
-test_nosymlinks()
-{
-# Setup test dirs.
-    slink_name="$LOCAL_PATH/nosymlinks/source"
-    slink_target="$LOCAL_PATH/nosymlinks/target"
-    mkdir_target="$LOCAL_PATH/nosymlinks/a"
-    dir1="$LOCAL_PATH/nosymlinks/foo"
-    dir2="$LOCAL_PATH/nosymlinks/foo/bar"
-    get_target="$LOCAL_PATH/nosymlinks/foo/bar/testfile"
-
-    rm -f $slink_target
-    rm -f $slink_name
-    rm -rf $mkdir_target
-    rm -rf $dir1
-
-    touch $slink_target
-    ln -s $slink_target $slink_name
-
-    mkdir $dir1
-    mkdir $dir2
-    touch $get_target
-
-# Getting a file through a symlink name should fail.
-    tmpfile=$PREFIX/smbclient_interactive_prompt_commands
-    cat > $tmpfile <<EOF
-get source
-quit
-EOF
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/nosymlinks -I $SERVER_IP $ADDARGS < $tmpfile 2>&1'
-    eval echo "$cmd"
-    out=`eval $cmd`
-    ret=$?
-    rm -f $tmpfile
-
-    if [ $ret -ne 0 ] ; then
-       echo "$out"
-       echo "failed accessing nosymlinks with error $ret"
-       false
-       return
-    fi
-
-    echo "$out" | grep 'NT_STATUS_ACCESS_DENIED'
-    ret=$?
-    if [ $ret -ne 0 ] ; then
-       echo "$out"
-       echo "failed - should get NT_STATUS_ACCESS_DENIED getting \\nosymlinks\\source"
-       false
-       return
-    fi
-
-# But we should be able to create and delete directories.
-    cat > $tmpfile <<EOF
-mkdir a
-mkdir a\\b
-quit
-EOF
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/nosymlinks -I $SERVER_IP $ADDARGS < $tmpfile 2>&1'
-    eval echo "$cmd"
-    out=`eval $cmd`
-    ret=$?
-    rm -f $tmpfile
-
-    if [ $ret -ne 0 ] ; then
-       echo "$out"
-       echo "failed accessing nosymlinks with error $ret"
-       false
-       return
-    fi
-
-    echo "$out" | grep 'NT_STATUS'
-    ret=$?
-    if [ $ret -eq 0 ] ; then
-	echo "$out"
-	echo "failed - NT_STATUS_XXXX doing mkdir a; mkdir a\\b on \\nosymlinks"
-	false
-    fi
-
-# Ensure regular file/directory access also works.
-    cat > $tmpfile <<EOF
-cd foo\\bar
-ls
-get testfile -
-quit
-EOF
-    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/nosymlinks -I $SERVER_IP $ADDARGS < $tmpfile 2>&1'
-    eval echo "$cmd"
-    out=`eval $cmd`
-    ret=$?
-    rm -f $tmpfile
-
-    if [ $ret -ne 0 ] ; then
-       echo "$out"
-       echo "failed accessing nosymlinks with error $ret"
-       false
-       return
-    fi
-
-    echo "$out" | grep 'NT_STATUS'
-    ret=$?
-    if [ $ret -eq 0 ] ; then
-       echo "$out"
-       echo "failed - NT_STATUS_XXXX doing cd foo\\bar; get testfile on \\nosymlinks"
-       false
-       return
-    fi
-}
 
 testit "smbclient -L $SERVER_IP" $SMBCLIENT -L $SERVER_IP -N -p 139 || failed=`expr $failed + 1`
 testit "smbclient -L $SERVER -I $SERVER_IP" $SMBCLIENT -L $SERVER -I $SERVER_IP -N -p 139 -c quit || failed=`expr $failed + 1`
@@ -1262,10 +1155,6 @@ testit "Ensure widelinks are restricted" \
     test_widelinks || \
     failed=`expr $failed + 1`
 
-testit "follow symlinks = no" \
-    test_nosymlinks || \
-    failed=`expr $failed + 1`
-
 testit "rm -rf $LOGDIR" \
     rm -rf $LOGDIR || \
     failed=`expr $failed + 1`
diff --git a/source3/smbd/dir.c b/source3/smbd/dir.c
index 3432788..3805915 100644
--- a/source3/smbd/dir.c
+++ b/source3/smbd/dir.c
@@ -1588,8 +1588,7 @@ static int smb_Dir_destructor(struct smb_Dir *dirp)
  Open a directory.
 ********************************************************************/
 
-static struct smb_Dir *OpenDir_internal(TALLOC_CTX *mem_ctx,
-			connection_struct *conn,
+struct smb_Dir *OpenDir(TALLOC_CTX *mem_ctx, connection_struct *conn,
 			const char *name,
 			const char *mask,
 			uint32_t attr)
@@ -1601,21 +1600,27 @@ static struct smb_Dir *OpenDir_internal(TALLOC_CTX *mem_ctx,
 		return NULL;
 	}
 
-	dirp->dir = SMB_VFS_OPENDIR(conn, name, mask, attr);
-	if (!dirp->dir) {
-		DEBUG(5,("OpenDir: Can't open %s. %s\n", name,
-			 strerror(errno) ));
-		goto fail;
-	}
-
 	dirp->conn = conn;
 	dirp->name_cache_size = lp_directory_name_cache_size(SNUM(conn));
 
+	dirp->dir_path = talloc_strdup(dirp, name);
+	if (!dirp->dir_path) {
+		errno = ENOMEM;
+		goto fail;
+	}
+
 	if (sconn && !sconn->using_smb2) {
 		sconn->searches.dirhandles_open++;
 	}
 	talloc_set_destructor(dirp, smb_Dir_destructor);
 
+	dirp->dir = SMB_VFS_OPENDIR(conn, dirp->dir_path, mask, attr);
+	if (!dirp->dir) {
+		DEBUG(5,("OpenDir: Can't open %s. %s\n", dirp->dir_path,
+			 strerror(errno) ));
+		goto fail;
+	}
+
 	return dirp;
 
   fail:
@@ -1623,76 +1628,6 @@ static struct smb_Dir *OpenDir_internal(TALLOC_CTX *mem_ctx,
 	return NULL;
 }
 
-/****************************************************************************
- Open a directory handle by pathname, ensuring it's under the share path.
-****************************************************************************/
-
-static struct smb_Dir *open_dir_safely(TALLOC_CTX *ctx,
-					connection_struct *conn,
-					const char *name,
-					const char *wcard,
-					uint32_t attr)
-{
-	struct smb_Dir *dir_hnd = NULL;
-	char *saved_dir = vfs_GetWd(ctx, conn);
-	NTSTATUS status;
-
-	if (saved_dir == NULL) {
-		return NULL;
-	}
-
-	if (vfs_ChDir(conn, name) == -1) {
-		goto out;
-	}
-
-	/*
-	 * Now the directory is pinned, use
-	 * REALPATH to ensure we can access it.
-	 */
-	status = check_name(conn, ".");
-	if (!NT_STATUS_IS_OK(status)) {
-		goto out;
-	}
-
-	dir_hnd = OpenDir_internal(ctx,
-				conn,
-				".",
-				wcard,
-				attr);
-
-	if (dir_hnd == NULL) {
-		goto out;
-	}
-
-	/*
-	 * OpenDir_internal only gets "." as the dir name.
-	 * Store the real dir name here.
-	 */
-
-	dir_hnd->dir_path = talloc_strdup(dir_hnd, name);
-	if (!dir_hnd->dir_path) {
-		errno = ENOMEM;
-	}
-
-  out:
-
-	vfs_ChDir(conn, saved_dir);
-	TALLOC_FREE(saved_dir);
-	return dir_hnd;
-}
-
-struct smb_Dir *OpenDir(TALLOC_CTX *mem_ctx, connection_struct *conn,
-			const char *name,
-			const char *mask,
-			uint32_t attr)
-{
-	return open_dir_safely(mem_ctx,
-				conn,
-				name,
-				mask,
-				attr);
-}
-
 /*******************************************************************
  Open a directory from an fsp.
 ********************************************************************/
@@ -1706,17 +1641,7 @@ static struct smb_Dir *OpenDir_fsp(TALLOC_CTX *mem_ctx, connection_struct *conn,
 	struct smbd_server_connection *sconn = conn->sconn;
 
 	if (!dirp) {
-		goto fail;
-	}
-
-	if (!fsp->is_directory) {
-		errno = EBADF;
-		goto fail;
-	}
-
-	if (fsp->fh->fd == -1) {
-		errno = EBADF;
-		goto fail;
+		return NULL;
 	}
 
 	dirp->conn = conn;
@@ -1728,33 +1653,36 @@ static struct smb_Dir *OpenDir_fsp(TALLOC_CTX *mem_ctx, connection_struct *conn,
 		goto fail;
 	}
 
-	dirp->dir = SMB_VFS_FDOPENDIR(fsp, mask, attr);
-	if (dirp->dir != NULL) {
-		dirp->fsp = fsp;
-	} else {
-		DEBUG(10,("OpenDir_fsp: SMB_VFS_FDOPENDIR on %s returned "
-			"NULL (%s)\n",
-			dirp->dir_path,
-			strerror(errno)));
-		if (errno != ENOSYS) {
-			goto fail;
+	if (sconn && !sconn->using_smb2) {
+		sconn->searches.dirhandles_open++;
+	}
+	talloc_set_destructor(dirp, smb_Dir_destructor);
+
+	if (fsp->is_directory && fsp->fh->fd != -1) {
+		dirp->dir = SMB_VFS_FDOPENDIR(fsp, mask, attr);
+		if (dirp->dir != NULL) {
+			dirp->fsp = fsp;
+		} else {
+			DEBUG(10,("OpenDir_fsp: SMB_VFS_FDOPENDIR on %s returned "
+				"NULL (%s)\n",
+				dirp->dir_path,
+				strerror(errno)));
+			if (errno != ENOSYS) {
+				return NULL;
+			}
 		}
 	}
 
 	if (dirp->dir == NULL) {
-		/* FDOPENDIR is not supported. Use OPENDIR instead. */
-		TALLOC_FREE(dirp);
-		return open_dir_safely(mem_ctx,
-					conn,
-					fsp->fsp_name->base_name,
-					mask,
-					attr);
+		/* FDOPENDIR didn't work. Use OPENDIR instead. */
+		dirp->dir = SMB_VFS_OPENDIR(conn, dirp->dir_path, mask, attr);
 	}
 
-	if (sconn && !sconn->using_smb2) {
-		sconn->searches.dirhandles_open++;
+	if (!dirp->dir) {
+		DEBUG(5,("OpenDir_fsp: Can't open %s. %s\n", dirp->dir_path,
+			 strerror(errno) ));
+		goto fail;
 	}
-	talloc_set_destructor(dirp, smb_Dir_destructor);
 
 	return dirp;
 
diff --git a/source3/smbd/filename.c b/source3/smbd/filename.c
index fcc6606..e89575d 100644
--- a/source3/smbd/filename.c
+++ b/source3/smbd/filename.c
@@ -1067,7 +1067,7 @@ NTSTATUS check_name(connection_struct *conn, const char *name)
 	}
 
 	if (!lp_widelinks(SNUM(conn)) || !lp_follow_symlinks(SNUM(conn))) {
-		status = check_reduced_name(conn, NULL, name);
+		status = check_reduced_name(conn,name);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(5,("check_name: name %s failed with %s\n",name,
 						nt_errstr(status)));
diff --git a/source3/smbd/open.c b/source3/smbd/open.c
index 8daae8d..3af315a 100644
--- a/source3/smbd/open.c
+++ b/source3/smbd/open.c
@@ -345,268 +345,6 @@ static NTSTATUS check_base_file_access(struct connection_struct *conn,
 }
 
 /****************************************************************************
- Handle differing symlink errno's
-****************************************************************************/
-
-static int link_errno_convert(int err)
-{
-#if defined(ENOTSUP) && defined(OSF1)
-	/* handle special Tru64 errno */
-	if (err == ENOTSUP) {
-		err = ELOOP;
-	}
-#endif /* ENOTSUP */
-#ifdef EFTYPE
-	/* fix broken NetBSD errno */
-	if (err == EFTYPE) {
-		err = ELOOP;
-	}
-#endif /* EFTYPE */
-	/* fix broken FreeBSD errno */
-	if (err == EMLINK) {
-		err = ELOOP;
-	}
-	return err;
-}
-
-static int non_widelink_open(struct connection_struct *conn,
-			const char *conn_rootdir,
-			files_struct *fsp,
-			struct smb_filename *smb_fname,
-			int flags,
-			mode_t mode,
-			unsigned int link_depth);
-
-/****************************************************************************
- Follow a symlink in userspace.
-****************************************************************************/
-
-static int process_symlink_open(struct connection_struct *conn,
-			const char *conn_rootdir,
-			files_struct *fsp,
-			struct smb_filename *smb_fname,
-			int flags,
-			mode_t mode,
-			unsigned int link_depth)
-{
-	int fd = -1;
-	char *link_target = NULL;
-	int link_len = -1;
-	char *oldwd = NULL;
-	size_t rootdir_len = 0;
-	char *resolved_name = NULL;
-	bool matched = false;
-	int saved_errno = 0;
-
-	/*
-	 * Ensure we don't get stuck in a symlink loop.
-	 */
-	link_depth++;
-	if (link_depth >= 20) {
-		errno = ELOOP;
-		goto out;
-	}
-
-	/* Allocate space for the link target. */
-	link_target = talloc_array(talloc_tos(), char, PATH_MAX);
-	if (link_target == NULL) {
-		errno = ENOMEM;
-		goto out;
-	}
-
-	/* Read the link target. */
-	link_len = SMB_VFS_READLINK(conn,
-				smb_fname->base_name,
-				link_target,
-				PATH_MAX - 1);
-	if (link_len == -1) {
-		goto out;
-	}
-
-	/* Ensure it's at least null terminated. */
-	link_target[link_len] = '\0';
-
-	/* Convert to an absolute path. */
-	resolved_name = SMB_VFS_REALPATH(conn, link_target);
-	if (resolved_name == NULL) {
-		goto out;
-	}
-
-	/*
-	 * We know conn_rootdir starts with '/' and
-	 * does not end in '/'. FIXME ! Should we
-	 * smb_assert this ?
-	 */
-	rootdir_len = strlen(conn_rootdir);
-
-	matched = (strncmp(conn_rootdir, resolved_name, rootdir_len) == 0);
-	if (!matched) {
-		errno = EACCES;
-		goto out;
-	}
-
-	/*
-	 * Turn into a path relative to the share root.
-	 */
-	if (resolved_name[rootdir_len] == '\0') {
-		/* Link to the root of the share. */
-		smb_fname->base_name = talloc_strdup(talloc_tos(), ".");
-		if (smb_fname->base_name == NULL) {
-			errno = ENOMEM;
-			goto out;
-		}
-	} else if (resolved_name[rootdir_len] == '/') {
-		smb_fname->base_name = &resolved_name[rootdir_len+1];
-	} else {
-		errno = EACCES;
-		goto out;
-	}
-
-	oldwd = vfs_GetWd(talloc_tos(), conn);
-	if (oldwd == NULL) {
-		goto out;
-	}
-
-	/* Ensure we operate from the root of the share. */
-	if (vfs_ChDir(conn, conn_rootdir) == -1) {
-		goto out;
-	}
-
-	/* And do it all again.. */
-	fd = non_widelink_open(conn,
-				conn_rootdir,
-				fsp,
-				smb_fname,
-				flags,
-				mode,
-				link_depth);
-	if (fd == -1) {
-		saved_errno = errno;
-	}
-
-  out:
-
-	SAFE_FREE(resolved_name);
-	TALLOC_FREE(link_target);
-	if (oldwd != NULL) {
-		int ret = vfs_ChDir(conn, oldwd);
-		if (ret == -1) {
-			smb_panic("unable to get back to old directory\n");
-		}
-		TALLOC_FREE(oldwd);
-	}
-	if (saved_errno != 0) {
-		errno = saved_errno;
-	}
-	return fd;
-}
-
-/****************************************************************************
- Non-widelink open.
-****************************************************************************/
-
-static int non_widelink_open(struct connection_struct *conn,
-			const char *conn_rootdir,
-			files_struct *fsp,
-			struct smb_filename *smb_fname,
-			int flags,
-			mode_t mode,
-			unsigned int link_depth)
-{
-	NTSTATUS status;
-	int fd = -1;
-	struct smb_filename *smb_fname_rel = NULL;
-	int saved_errno = 0;
-	char *oldwd = NULL;
-	char *parent_dir = NULL;
-	const char *final_component = NULL;
-
-	if (!parent_dirname(talloc_tos(),
-			smb_fname->base_name,
-			&parent_dir,
-			&final_component)) {
-		goto out;
-	}
-
-	oldwd = vfs_GetWd(talloc_tos(), conn);
-	if (oldwd == NULL) {
-		goto out;
-	}
-
-	/* Pin parent directory in place. */
-	if (vfs_ChDir(conn, parent_dir) == -1) {
-		goto out;
-	}
-
-	/* Ensure the relative path is below the share. */
-	status = check_reduced_name(conn, parent_dir, final_component);
-	if (!NT_STATUS_IS_OK(status)) {
-		saved_errno = map_errno_from_nt_status(status);
-		goto out;
-	}
-
-	smb_fname_rel = synthetic_smb_fname(talloc_tos(),
-				final_component,
-				smb_fname->stream_name,
-				&smb_fname->st);
-
-	flags |= O_NOFOLLOW;
-
-	{
-		struct smb_filename *tmp_name = fsp->fsp_name;
-		fsp->fsp_name = smb_fname_rel;
-		fd = SMB_VFS_OPEN(conn, smb_fname_rel, fsp, flags, mode);
-		fsp->fsp_name = tmp_name;
-	}
-
-	if (fd == -1) {
-		saved_errno = link_errno_convert(errno);
-		if (saved_errno == ELOOP) {
-			if (fsp->posix_flags & FSP_POSIX_FLAGS_OPEN) {
-				/* Never follow symlinks on posix open. */
-				goto out;
-			}
-			if (!lp_follow_symlinks(SNUM(conn))) {
-				/* Explicitly no symlinks. */
-				goto out;
-			}
-			/*
-			 * We have a symlink. Follow in userspace
-			 * to ensure it's under the share definition.
-			 */
-			fd = process_symlink_open(conn,
-					conn_rootdir,
-					fsp,
-					smb_fname_rel,
-					flags,
-					mode,
-					link_depth);
-			if (fd == -1) {
-				saved_errno =
-					link_errno_convert(errno);
-			}
-		}
-	}
-
-  out:
-
-	TALLOC_FREE(parent_dir);
-	TALLOC_FREE(smb_fname_rel);
-
-	if (oldwd != NULL) {
-		int ret = vfs_ChDir(conn, oldwd);
-		if (ret == -1) {
-			smb_panic("unable to get back to old directory\n");
-		}
-		TALLOC_FREE(oldwd);
-	}
-	if (saved_errno != 0) {
-		errno = saved_errno;
-	}
-	return fd;
-}
-
-/****************************************************************************
  fd support routines - attempt to do a dos_open.
 ****************************************************************************/
 
@@ -618,7 +356,8 @@ NTSTATUS fd_open(struct connection_struct *conn,
 	struct smb_filename *smb_fname = fsp->fsp_name;
 	NTSTATUS status = NT_STATUS_OK;
 
-	/*
+#ifdef O_NOFOLLOW
+	/* 
 	 * Never follow symlinks on a POSIX client. The
 	 * client should be doing this.
 	 */
@@ -626,31 +365,29 @@ NTSTATUS fd_open(struct connection_struct *conn,
 	if ((fsp->posix_flags & FSP_POSIX_FLAGS_OPEN) || !lp_follow_symlinks(SNUM(conn))) {
 		flags |= O_NOFOLLOW;
 	}
+#endif
 
-	/* Ensure path is below share definition. */
-	if (!lp_widelinks(SNUM(conn))) {
-		const char *conn_rootdir = SMB_VFS_CONNECTPATH(conn,
-						smb_fname->base_name);
-		if (conn_rootdir == NULL) {
-			return NT_STATUS_NO_MEMORY;
-		}
-		/*
-		 * Only follow symlinks within a share
-		 * definition.
-		 */
-		fsp->fh->fd = non_widelink_open(conn,
-					conn_rootdir,
-					fsp,
-					smb_fname,
-					flags,
-					mode,
-					0);
-	} else {
-		fsp->fh->fd = SMB_VFS_OPEN(conn, smb_fname, fsp, flags, mode);
-	}
-
+	fsp->fh->fd = SMB_VFS_OPEN(conn, smb_fname, fsp, flags, mode);
 	if (fsp->fh->fd == -1) {
-		int posix_errno = link_errno_convert(errno);
+		int posix_errno = errno;
+#ifdef O_NOFOLLOW
+#if defined(ENOTSUP) && defined(OSF1)
+		/* handle special Tru64 errno */
+		if (errno == ENOTSUP) {
+			posix_errno = ELOOP;
+		}
+#endif /* ENOTSUP */
+#ifdef EFTYPE
+		/* fix broken NetBSD errno */
+		if (errno == EFTYPE) {
+			posix_errno = ELOOP;
+		}
+#endif /* EFTYPE */
+		/* fix broken FreeBSD errno */
+		if (errno == EMLINK) {
+			posix_errno = ELOOP;
+		}
+#endif /* O_NOFOLLOW */
 		status = map_nt_error_from_unix(posix_errno);
 		if (errno == EMFILE) {
 			static time_t last_warned = 0L;
diff --git a/source3/smbd/proto.h b/source3/smbd/proto.h
index aa4d1d9..c9c734c 100644
--- a/source3/smbd/proto.h
+++ b/source3/smbd/proto.h
@@ -1198,9 +1198,7 @@ const char *vfs_readdirname(connection_struct *conn, void *p,
 			    SMB_STRUCT_STAT *sbuf, char **talloced);
 int vfs_ChDir(connection_struct *conn, const char *path);
 char *vfs_GetWd(TALLOC_CTX *ctx, connection_struct *conn);
-NTSTATUS check_reduced_name(connection_struct *conn,
-			const char *cwd_name,
-			const char *fname);
+NTSTATUS check_reduced_name(connection_struct *conn, const char *fname);
 NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
 			const char *fname,
 			struct smb_request *smbreq);
diff --git a/source3/smbd/smb2_query_directory.c b/source3/smbd/smb2_query_directory.c
index 1703310..4b6ca1b 100644
--- a/source3/smbd/smb2_query_directory.c
+++ b/source3/smbd/smb2_query_directory.c
@@ -24,7 +24,6 @@
 #include "../libcli/smb/smb_common.h"
 #include "trans2.h"
 #include "../lib/util/tevent_ntstatus.h"
-#include "system/filesys.h"
 
 static struct tevent_req *smbd_smb2_query_directory_send(TALLOC_CTX *mem_ctx,
 					      struct tevent_context *ev,
@@ -323,23 +322,7 @@ static struct tevent_req *smbd_smb2_query_directory_send(TALLOC_CTX *mem_ctx,
 	}
 
 	if (in_flags & SMB2_CONTINUE_FLAG_REOPEN) {
-		int flags;
-
 		dptr_CloseDir(fsp);
-
-		/*
-		 * dptr_CloseDir() will close and invalidate the fsp's file
-		 * descriptor, we have to reopen it.
-		 */
-
-		flags = O_RDONLY;
-#ifdef O_DIRECTORY
-		flags |= O_DIRECTORY;
-#endif
-		status = fd_open(conn, fsp, flags, 0);
-		if (tevent_req_nterror(req, status)) {
-			return tevent_req_post(req, ev);
-		}
 	}
 
 	if (!smbreq->posix_pathnames) {
diff --git a/source3/smbd/vfs.c b/source3/smbd/vfs.c
index d3a5048..89f0ae1 100644
--- a/source3/smbd/vfs.c
+++ b/source3/smbd/vfs.c
@@ -1149,20 +1149,11 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
 /*******************************************************************
  Reduce a file name, removing .. elements and checking that
  it is below dir in the heirachy. This uses realpath.
-
- If cwd_name == NULL then fname is a client given path relative
- to the root path of the share.
-
- If cwd_name != NULL then fname is a client given path relative
- to cwd_name. cwd_name is relative to the root path of the share.
 ********************************************************************/
 
-NTSTATUS check_reduced_name(connection_struct *conn,
-				const char *cwd_name,
-				const char *fname)
+NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
 {
 	char *resolved_name = NULL;
-	char *new_fname = NULL;
 	bool allow_symlinks = true;
 	bool allow_widelinks = false;
 
@@ -1286,11 +1277,8 @@ NTSTATUS check_reduced_name(connection_struct *conn,
 			/* fname can't have changed in resolved_path. */
 			const char *p = &resolved_name[rootdir_len];
 
-			/*
-			 * UNIX filesystem semantics, names consisting
-			 * only of "." or ".." CANNOT be symlinks.
-			 */
-			if (ISDOT(fname) || ISDOTDOT(fname)) {
+			/* *p can be '\0' if fname was "." */
+			if (*p == '\0' && ISDOT(fname)) {
 				goto out;
 			}
 
@@ -1304,32 +1292,11 @@ NTSTATUS check_reduced_name(connection_struct *conn,
 			}
 
 			p++;
-
-			/*
-			 * If cwd_name is present and not ".",
-			 * then fname is relative to that, not
-			 * the root of the share. Make sure the
-			 * path we check is the one the client
-			 * sent (cwd_name+fname).
-			 */
-			if (cwd_name != NULL && !ISDOT(cwd_name)) {
-				new_fname = talloc_asprintf(talloc_tos(),
-							"%s/%s",
-							cwd_name,
-							fname);
-				if (new_fname == NULL) {
-					SAFE_FREE(resolved_name);
-					return NT_STATUS_NO_MEMORY;
-				}
-				fname = new_fname;
-			}
-
 			if (strcmp(fname, p)!=0) {
 				DEBUG(2, ("check_reduced_name: Bad access "
 					"attempt: %s is a symlink to %s\n",
 					  fname, p));
 				SAFE_FREE(resolved_name);
-				TALLOC_FREE(new_fname);
 				return NT_STATUS_ACCESS_DENIED;
 			}
 		}
@@ -1339,7 +1306,6 @@ NTSTATUS check_reduced_name(connection_struct *conn,
 
 	DBG_INFO("%s reduced to %s\n", fname, resolved_name);
 	SAFE_FREE(resolved_name);
-	TALLOC_FREE(new_fname);
 	return NT_STATUS_OK;
 }
 
diff --git a/source4/torture/smb2/dir.c b/source4/torture/smb2/dir.c
index db8e456..98844b4 100644
--- a/source4/torture/smb2/dir.c
+++ b/source4/torture/smb2/dir.c
@@ -674,7 +674,7 @@ bool fill_result(void *private_data,
 	return true;
 }
 
-enum continue_type {CONT_SINGLE, CONT_INDEX, CONT_RESTART, CONT_REOPEN};
+enum continue_type {CONT_SINGLE, CONT_INDEX, CONT_RESTART};
 
 static NTSTATUS multiple_smb2_search(struct smb2_tree *tree,
 				     TALLOC_CTX *tctx,
@@ -700,9 +700,6 @@ static NTSTATUS multiple_smb2_search(struct smb2_tree *tree,
 
 	/* The search should start from the beginning everytime */
 	f.in.continue_flags = SMB2_CONTINUE_FLAG_RESTART;
-	if (cont_type == CONT_REOPEN) {
-		f.in.continue_flags = SMB2_CONTINUE_FLAG_REOPEN;
-	}
 
 	do {
 		status = smb2_find_level(tree, tree, &f, &count, &d);
@@ -806,23 +803,18 @@ static bool test_many_files(struct torture_context *tctx,
 		{"SMB2_FIND_BOTH_DIRECTORY_INFO",    "SINGLE",  SMB2_FIND_BOTH_DIRECTORY_INFO,    RAW_SEARCH_DATA_BOTH_DIRECTORY_INFO,    CONT_SINGLE},
 		{"SMB2_FIND_BOTH_DIRECTORY_INFO",    "INDEX",   SMB2_FIND_BOTH_DIRECTORY_INFO,    RAW_SEARCH_DATA_BOTH_DIRECTORY_INFO,    CONT_INDEX},
 		{"SMB2_FIND_BOTH_DIRECTORY_INFO",    "RESTART", SMB2_FIND_BOTH_DIRECTORY_INFO,    RAW_SEARCH_DATA_BOTH_DIRECTORY_INFO,    CONT_RESTART},
-		{"SMB2_FIND_BOTH_DIRECTORY_INFO",    "REOPEN",  SMB2_FIND_BOTH_DIRECTORY_INFO,    RAW_SEARCH_DATA_BOTH_DIRECTORY_INFO,    CONT_REOPEN},
 		{"SMB2_FIND_DIRECTORY_INFO",         "SINGLE",  SMB2_FIND_DIRECTORY_INFO,         RAW_SEARCH_DATA_DIRECTORY_INFO,         CONT_SINGLE},
 		{"SMB2_FIND_DIRECTORY_INFO",         "INDEX",   SMB2_FIND_DIRECTORY_INFO,         RAW_SEARCH_DATA_DIRECTORY_INFO,         CONT_INDEX},
 		{"SMB2_FIND_DIRECTORY_INFO",         "RESTART", SMB2_FIND_DIRECTORY_INFO,         RAW_SEARCH_DATA_DIRECTORY_INFO,         CONT_RESTART},
-		{"SMB2_FIND_DIRECTORY_INFO",         "REOPEN",  SMB2_FIND_DIRECTORY_INFO,         RAW_SEARCH_DATA_DIRECTORY_INFO,         CONT_REOPEN},
 		{"SMB2_FIND_FULL_DIRECTORY_INFO",    "SINGLE",  SMB2_FIND_FULL_DIRECTORY_INFO,    RAW_SEARCH_DATA_FULL_DIRECTORY_INFO,    CONT_SINGLE},
 		{"SMB2_FIND_FULL_DIRECTORY_INFO",    "INDEX",   SMB2_FIND_FULL_DIRECTORY_INFO,    RAW_SEARCH_DATA_FULL_DIRECTORY_INFO,    CONT_INDEX},
 		{"SMB2_FIND_FULL_DIRECTORY_INFO",    "RESTART", SMB2_FIND_FULL_DIRECTORY_INFO,    RAW_SEARCH_DATA_FULL_DIRECTORY_INFO,    CONT_RESTART},
-		{"SMB2_FIND_FULL_DIRECTORY_INFO",    "REOPEN",  SMB2_FIND_FULL_DIRECTORY_INFO,    RAW_SEARCH_DATA_FULL_DIRECTORY_INFO,    CONT_REOPEN},
 		{"SMB2_FIND_ID_FULL_DIRECTORY_INFO", "SINGLE",  SMB2_FIND_ID_FULL_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_FULL_DIRECTORY_INFO, CONT_SINGLE},
 		{"SMB2_FIND_ID_FULL_DIRECTORY_INFO", "INDEX",   SMB2_FIND_ID_FULL_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_FULL_DIRECTORY_INFO, CONT_INDEX},
 		{"SMB2_FIND_ID_FULL_DIRECTORY_INFO", "RESTART", SMB2_FIND_ID_FULL_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_FULL_DIRECTORY_INFO, CONT_RESTART},
-		{"SMB2_FIND_ID_FULL_DIRECTORY_INFO", "REOPEN",  SMB2_FIND_ID_FULL_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_FULL_DIRECTORY_INFO, CONT_REOPEN},
 		{"SMB2_FIND_ID_BOTH_DIRECTORY_INFO", "SINGLE",  SMB2_FIND_ID_BOTH_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_BOTH_DIRECTORY_INFO, CONT_SINGLE},
 		{"SMB2_FIND_ID_BOTH_DIRECTORY_INFO", "INDEX",   SMB2_FIND_ID_BOTH_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_BOTH_DIRECTORY_INFO, CONT_INDEX},
-		{"SMB2_FIND_ID_BOTH_DIRECTORY_INFO", "RESTART", SMB2_FIND_ID_BOTH_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_BOTH_DIRECTORY_INFO, CONT_RESTART},
-		{"SMB2_FIND_ID_BOTH_DIRECTORY_INFO", "REOPEN",  SMB2_FIND_ID_BOTH_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_BOTH_DIRECTORY_INFO, CONT_REOPEN},
+		{"SMB2_FIND_ID_BOTH_DIRECTORY_INFO", "RESTART", SMB2_FIND_ID_BOTH_DIRECTORY_INFO, RAW_SEARCH_DATA_ID_BOTH_DIRECTORY_INFO, CONT_RESTART}
 	};
 
 	smb2_deltree(tree, DNAME);
