From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Thu, 20 Jul 2017 13:23:22 -0400
Subject: HYP-4844: Disable hash recomputation optimization and write new tdb
 record always.

---
 lib/tdb/common/tdb.c             |   4 +-
 source3/lib/dbwrap/dbwrap_open.c |  23 ++++++
 source3/lib/dbwrap/dbwrap_open.h |   1 +
 source3/smbd/smb2_server.c       |   4 +-
 source3/smbd/smbXsrv_open.c      | 148 ++++++++++++++++++++++++++-------------
 5 files changed, 129 insertions(+), 51 deletions(-)

diff --git a/lib/tdb/common/tdb.c b/lib/tdb/common/tdb.c
index 9885d8c..6ec5bda 100644
--- a/lib/tdb/common/tdb.c
+++ b/lib/tdb/common/tdb.c
@@ -151,13 +151,13 @@ static int tdb_update_hash(struct tdb_context *tdb, TDB_DATA key, uint32_t hash,
 		return -1;
 
 	/* it could be an exact duplicate of what is there - this is
-	 * surprisingly common (eg. with a ldb re-index). */
+	 * surprisingly common (eg. with a ldb re-index). 
 	if (rec.key_len == key.dsize &&
 	    rec.data_len == dbuf.dsize &&
 	    rec.full_hash == hash &&
 	    tdb_parse_record(tdb, key, tdb_update_hash_cmp, &dbuf) == 0) {
 		return 0;
-	}
+	} */
 
 	/* must be long enough key, data and tailer */
 	if (rec.rec_len < key.dsize + dbuf.dsize + sizeof(tdb_off_t)) {
diff --git a/source3/lib/dbwrap/dbwrap_open.c b/source3/lib/dbwrap/dbwrap_open.c
index 321df99..e12c0e3 100644
--- a/source3/lib/dbwrap/dbwrap_open.c
+++ b/source3/lib/dbwrap/dbwrap_open.c
@@ -182,3 +182,26 @@ void closedb_for_index (struct db_context * db_ctx[], int index)
 	    db_ctx[index] = NULL;
         }
 }
+
+void closedb (struct db_context * db_ctx)
+{
+        struct db_tdb_ctx * tdb_context;
+        DEBUG(3, ("closedb called with db_context %p \n", db_ctx));
+
+        if (db_ctx != NULL ) {
+            /*close db
+            db_context->private_data is struct db_tdb_ctx *.
+            db_context->private_data->wtdb is struct tdb_wrap *;
+            db_context->private_data->wtdb->tdb is finally, but to close the tdb,
+            all we need to do is TALLOC_FREE the tdb_wrap *.
+            */
+            if (db_ctx->private_data) {
+                tdb_context = (struct db_tdb_ctx *) db_ctx->private_data;
+                /* freeing wtdb causes the tdb file to be closed */
+                DEBUG(2, ("closedb closing tdb at 0x%p \n",tdb_context->wtdb));
+                TALLOC_FREE(tdb_context->wtdb);
+                TALLOC_FREE(tdb_context);
+            }
+        }
+}
+
diff --git a/source3/lib/dbwrap/dbwrap_open.h b/source3/lib/dbwrap/dbwrap_open.h
index 95523b3..1b43ead 100644
--- a/source3/lib/dbwrap/dbwrap_open.h
+++ b/source3/lib/dbwrap/dbwrap_open.h
@@ -43,4 +43,5 @@ struct db_context *db_open(TALLOC_CTX *mem_ctx,
 			   uint64_t dbwrap_flags);
 
 void closedb_for_index (struct db_context * db_ctx[], int index);
+void closedb (struct db_context * db_ctx);
 #endif /* __DBWRAP_OPEN_H__ */
diff --git a/source3/smbd/smb2_server.c b/source3/smbd/smb2_server.c
index 850a8b3..1163dd2 100644
--- a/source3/smbd/smb2_server.c
+++ b/source3/smbd/smb2_server.c
@@ -3440,7 +3440,7 @@ static NTSTATUS smbd_smb2_request_next_incoming(struct smbXsrv_connection *xconn
 		 * we wait until they are on the wire until we
 		 * ask for the next request.
 		 */
-		DEBUG(3,("smbd_smb2_request_next_incoming: Pausing read from socket until sendq (size %d) drained\n",cur_send_queue_len));
+		DEBUG(3,("smbd_smb2_request_next_incoming: Pausing read from socket until sendq (size %d) drained\n",(int)cur_send_queue_len));
 		paused = true;
 		return NT_STATUS_OK;
 	}
@@ -3452,7 +3452,7 @@ static NTSTATUS smbd_smb2_request_next_incoming(struct smbXsrv_connection *xconn
 		return NT_STATUS_NO_MEMORY;
 	}
 	if (paused == true) {
-		DEBUG(3,("smbd_smb2_request_next_incoming: Unpausing read from socket with sendq (size %d)\n",cur_send_queue_len));
+		DEBUG(3,("smbd_smb2_request_next_incoming: Unpausing read from socket with sendq (size %d)\n",(int)cur_send_queue_len));
 		paused = false;
 	}
 
diff --git a/source3/smbd/smbXsrv_open.c b/source3/smbd/smbXsrv_open.c
index 07feb2d..7b00f39 100644
--- a/source3/smbd/smbXsrv_open.c
+++ b/source3/smbd/smbXsrv_open.c
@@ -319,12 +319,33 @@ nextIndex:
 	return status;
 }
 
+static bool file_copy (const char * source, const char * dest)
+{
+	int in_fd = open(source, O_RDONLY);
+	int out_fd = open(dest, O_WRONLY|O_CREAT);
+	char buf[8192];
+	if ( in_fd < 0 || out_fd < 0) goto fail;
+
+	while (1) {
+    		ssize_t result = read(in_fd, &buf[0], sizeof(buf));
+    		if (!result) break;
+    		if (result <= 0) goto fail;
+    		if (write(out_fd, &buf[0], result) != result) goto fail;
+	}
+	return true;
+fail:
+	if (in_fd > 0) close(in_fd);
+	if (out_fd > 0) close(out_fd);
+	return false;
+}
+
 NTSTATUS smbXsrv_open_global_init(void)
 {
-	char *global_path = NULL;
-	struct db_context *db_ctx = NULL;
-	NTSTATUS status = NT_STATUS_OK;
-	int index,saved_index;
+        char *global_path = NULL;
+        const char *tmp_path="/etc/samba/smbXsrv_open_global.tdb";
+        struct db_context *db_ctx = NULL;
+        NTSTATUS status = NT_STATUS_OK;
+        int index,saved_index;
 
         /**
          *  Not using the 'state' feature at the moment, so commenting it out
@@ -335,59 +356,93 @@ NTSTATUS smbXsrv_open_global_init(void)
 	};
         */
 
-	index = 0;
-	saved_index = svtfs_get_lockdir_index();
+        index = 0;
+        saved_index = svtfs_get_lockdir_index();
 
-	svtfs_set_lockdir_index(index);
-	DEBUG(5, ("smbXsrv_open_global_init: setting lockdir_index of 0\n"));
+        svtfs_set_lockdir_index(index);
+        DEBUG(5, ("smbXsrv_open_global_init: setting lockdir_index of 0\n"));
 
-	while (1) {
+        while (1) {
 
-		if (get_smbXsrv_open_global_db_ctx() != NULL) {
-			goto nextIndex;
-		}
+                if (get_smbXsrv_open_global_db_ctx() != NULL) {
+                        goto nextIndex;
+                }
 
-		global_path = svtfs_lock_path("smbXsrv_open_global.tdb");
-		if (global_path == NULL) {
-			status = NT_STATUS_NO_MEMORY;
-			break;
-		}
+                global_path = svtfs_lock_path("smbXsrv_open_global.tdb");
+                if (global_path == NULL) {
+                        status = NT_STATUS_NO_MEMORY;
+                        break;
+                }
+                /* Delete any old file */
+                unlink(tmp_path);
+                /* Copy the file to work with */
+                if (true != file_copy(global_path, tmp_path)) {
+                        DEBUG(1, ("Unable to copy %s to %s for initialization.\n",global_path,tmp_path));
+                        status = map_nt_error_from_unix_common(errno);
+                        break;
+                }
 
-		db_ctx = db_open(NULL, global_path,
-				 0, /* hash_size */
-				 TDB_DEFAULT | TDB_TRIM_SIZE |
-				 TDB_INCOMPATIBLE_HASH,
-				 O_RDWR | O_CREAT, 0600,
-				 DBWRAP_LOCK_ORDER_1,
-				 DBWRAP_FLAG_NONE);
-		TALLOC_FREE(global_path);
-		if (db_ctx == NULL) {
-			DEBUG(1, ("Null context on open_global\n"));
-			status = map_nt_error_from_unix_common(errno);
-			break;
-		}
+                db_ctx = db_open(NULL, tmp_path,
+                                0, /* hash_size */
+                                TDB_DEFAULT | TDB_TRIM_SIZE |
+                                TDB_INCOMPATIBLE_HASH,
+                                O_RDWR | O_CREAT, 0600,
+                                DBWRAP_LOCK_ORDER_1,
+                                DBWRAP_FLAG_NONE);
+                if (db_ctx == NULL) {
+                        DEBUG(1, ("Null context on open_global\n"));
+                        status = map_nt_error_from_unix_common(errno);
+                        rename(tmp_path, global_path);
+                        TALLOC_FREE(global_path);
+                        break;
+                }
 
-		set_smbXsrv_open_global_db_ctx(db_ctx);
-		status = dbwrap_traverse(get_smbXsrv_open_global_db_ctx(),
-					 smbXsrv_open_global_traverse_persist_fn,
-					 NULL, NULL);
-		scavenge_setup[index] = true;
+                status = dbwrap_traverse(db_ctx,
+                                smbXsrv_open_global_traverse_persist_fn,
+                                NULL, NULL);
+		closedb(db_ctx);
+                TALLOC_FREE(db_ctx);
+
+                /* Bulk of work has been done with tdb file in /var/tmp for performance. Now copy back*/
+                if (true != file_copy(tmp_path, global_path)) {
+                        DEBUG(1, ("Unable to copy %s back to original location.\n",global_path));
+                        status = map_nt_error_from_unix_common(errno);
+                        break;
+                }
+
+                db_ctx = db_open(NULL, global_path,
+                                0, /* hash_size */
+                                TDB_DEFAULT |
+                                TDB_INCOMPATIBLE_HASH,
+                                O_RDWR | O_CREAT, 0600,
+                                DBWRAP_LOCK_ORDER_1,
+                                DBWRAP_FLAG_NONE);
+
+                TALLOC_FREE(global_path);
+                if (db_ctx == NULL) {
+                        DEBUG(1, ("Null context on open_global\n"));
+                        status = map_nt_error_from_unix_common(errno);
+                        break;
+                }
+
+                set_smbXsrv_open_global_db_ctx(db_ctx);
+                scavenge_setup[index] = true;
 
 nextIndex:
-		index++;
-		if ( ( svtfs_storage_ip[index] == NULL) || ( index >= MAX_OPEN_GLOBAL_DB_CONTEXTS ) )  {
-			DEBUG(5, ("smbXsrv_session_open_init: breaking with lockdir_index of %i\n", index));
-			break;
-		}
+                index++;
+                if ( ( svtfs_storage_ip[index] == NULL) || ( index >= MAX_OPEN_GLOBAL_DB_CONTEXTS ) )  {
+                        DEBUG(5, ("smbXsrv_session_open_init: breaking with lockdir_index of %i\n", index));
+                        break;
+                }
 
-		DEBUG(5, ("smbXsrv_session_open_init: setting lockdir_index of %i\n", index));
-		svtfs_set_lockdir_index(index);
-	} /* end while(1) */
+                DEBUG(5, ("smbXsrv_session_open_init: setting lockdir_index of %i\n", index));
+                svtfs_set_lockdir_index(index);
+        } /* end while(1) */
 
-	DEBUG(5, ("smbXsrv_session_open_init: setting lockdir_index back to %d\n", saved_index));
-	svtfs_set_lockdir_index(saved_index);
+        DEBUG(5, ("smbXsrv_session_open_init: setting lockdir_index back to %d\n", saved_index));
+        svtfs_set_lockdir_index(saved_index);
 
-	return status;
+        return status;
 }
 
 /*
@@ -1323,7 +1378,6 @@ static NTSTATUS smbXsrv_open_clear_replay_cache(struct smbXsrv_open *op)
 
 NTSTATUS smbXsrv_open_update(struct smbXsrv_open *op)
 {
-	struct smbXsrv_open_table *table = op->table;
 	NTSTATUS status;
 	uint8_t key_buf[SMBXSRV_OPEN_GLOBAL_TDB_KEY_SIZE];
 	TDB_DATA key;
