From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Wed, 1 Jun 2016 11:07:36 -0400
Subject: HYP-1420: Full resilient handle support + undo partial persistent
 handle support.

---
 source3/librpc/idl/smbXsrv.idl         |   1 +
 source3/locking/brlock.c               |  32 +-
 source3/locking/locking.c              |  44 +--
 source3/locking/proto.h                |   1 +
 source3/locking/share_mode_lock.c      |  36 +++
 source3/smbd/close.c                   |   3 +-
 source3/smbd/durable.c                 | 147 ++++-----
 source3/smbd/files.c                   |   6 +
 source3/smbd/globals.h                 |   1 +
 source3/smbd/oplock.c                  |   8 +-
 source3/smbd/scavenger.c               |  20 +-
 source3/smbd/smb2_create.c             |  25 +-
 source3/smbd/smb2_ioctl_network_fs.c   |  72 +++--
 source3/smbd/smb2_negprot.c            |   7 -
 source3/smbd/smb2_tcon.c               |   6 -
 source3/smbd/smbXsrv_open.c            |  52 ++-
 source3/smbd/smbXsrv_session.c         |   4 +
 source4/torture/smb2/durable_v2_open.c | 570 +++++++++++++++++++++++++++++++--
 18 files changed, 854 insertions(+), 181 deletions(-)

diff --git a/source3/librpc/idl/smbXsrv.idl b/source3/librpc/idl/smbXsrv.idl
index fe86545..5850b63 100644
--- a/source3/librpc/idl/smbXsrv.idl
+++ b/source3/librpc/idl/smbXsrv.idl
@@ -424,6 +424,7 @@ interface smbXsrv
 		NTTIME					disconnect_time;
 		uint32					durable_timeout_msec;
 		boolean8				durable;
+                boolean8                                resilient;
 		DATA_BLOB				backend_cookie;
 	} smbXsrv_open_global0;
 
diff --git a/source3/locking/brlock.c b/source3/locking/brlock.c
index e8c8d89..3d529bc 100644
--- a/source3/locking/brlock.c
+++ b/source3/locking/brlock.c
@@ -1649,7 +1649,7 @@ bool brl_mark_disconnected(struct files_struct *fsp)
 
 	smblctx = fsp->op->global->open_persistent_id;
 
-	if (!fsp->op->global->durable) {
+	if (!(fsp->op->global->durable || fsp->op->global->resilient)) {
 		return false;
 	}
 
@@ -1671,8 +1671,10 @@ bool brl_mark_disconnected(struct files_struct *fsp)
 		 */
 
 		if (lock->context.smblctx != smblctx) {
-			TALLOC_FREE(br_lck);
-			return false;
+                        /*
+                         * This lock is not for this session; continue
+                         */
+                        continue;
 		}
 
 		if (lock->context.tid != tid) {
@@ -1708,14 +1710,17 @@ bool brl_reconnect_disconnected(struct files_struct *fsp)
 	unsigned int i;
 	struct server_id self = messaging_server_id(fsp->conn->sconn->msg_ctx);
 	struct byte_range_lock *br_lck = NULL;
+        int matched_locks = 0;
 
 	if (fsp->op == NULL) {
+		DEBUG(1, ("brl_reconnect_disconnected: fsp->op is null\n"));
 		return false;
 	}
 
 	smblctx = fsp->op->global->open_persistent_id;
 
-	if (!fsp->op->global->durable) {
+	if (!(fsp->op->global->durable || fsp->op->global->resilient)) {
+		DEBUG(1, ("brl_reconnect_disconnected: durable not set\n"));
 		return false;
 	}
 
@@ -1727,6 +1732,7 @@ bool brl_reconnect_disconnected(struct files_struct *fsp)
 
 	br_lck = brl_get_locks(talloc_tos(), fsp);
 	if (br_lck == NULL) {
+		DEBUG(1, ("brl_reconnect_disconnected: br_lck is null\n"));
 		return false;
 	}
 
@@ -1739,36 +1745,42 @@ bool brl_reconnect_disconnected(struct files_struct *fsp)
 		struct lock_struct *lock = &br_lck->lock_data[i];
 
 		/*
-		 * as this is a durable handle we only expect locks
+		 * If this is a durable handle we only expect locks
 		 * of the current file handle!
 		 */
 
 		if (lock->context.smblctx != smblctx) {
-			TALLOC_FREE(br_lck);
-			return false;
+                        /*
+                         *  This lock is not for this session; continue
+                         */
+                        continue;
 		}
 
 		if (lock->context.tid != TID_FIELD_INVALID) {
 			TALLOC_FREE(br_lck);
+			DEBUG(1, ("brl_reconnect_disconnected: invalid TID\n"));
 			return false;
 		}
 
 		if (!server_id_is_disconnected(&lock->context.pid)) {
 			TALLOC_FREE(br_lck);
+			DEBUG(1, ("brl_reconnect_disconnected: server ID not disconnected\n"));
 			return false;
 		}
 
 		if (lock->fnum != FNUM_FIELD_INVALID) {
 			TALLOC_FREE(br_lck);
+			DEBUG(1, ("brl_reconnect_disconnected: invalid FNUM\n"));
 			return false;
 		}
 
 		lock->context.pid = self;
 		lock->context.tid = tid;
 		lock->fnum = fnum;
+                matched_locks++;
 	}
 
-	fsp->current_lock_count = br_lck->num_locks;
+	fsp->current_lock_count = matched_locks;
 	br_lck->modified = true;
 	TALLOC_FREE(br_lck);
 	return true;
@@ -2252,6 +2264,8 @@ bool brl_cleanup_disconnected(struct file_id fid, uint64_t open_persistent_id)
 				  "%s used by server %s, do not cleanup\n",
 				  file_id_string(frame, &fid),
 				  server_id_str_buf(ctx->pid, &tmp)));
+			/* This means a durable handle was already reconnected in this session, don't cleanup */
+			/* return false (ret == false) here so the open for this open_persistent_id is not cleaned up */
 			goto done;
 		}
 
@@ -2262,6 +2276,8 @@ bool brl_cleanup_disconnected(struct file_id fid, uint64_t open_persistent_id)
 				  file_id_string(frame, &fid),
 				  (unsigned long long)open_persistent_id,
 				  (unsigned long long)ctx->smblctx));
+			/* This means a durable handle was already reconnected in this session, don't cleanup */
+			/* return false (ret == false) here so the open for this open_persistent_id is not cleaned up */
 			goto done;
 		}
 	}
diff --git a/source3/locking/locking.c b/source3/locking/locking.c
index 5a97460..9936670 100644
--- a/source3/locking/locking.c
+++ b/source3/locking/locking.c
@@ -865,6 +865,7 @@ static struct share_mode_entry *find_share_mode_entry(
 
 	for (i=0; i<d->num_share_modes; i++) {
 		struct share_mode_entry *e = &d->share_modes[i];
+		DEBUG(10, ("Processing share mode entry with gen_id %lu and share_file_id %lu\n", fsp->fh->gen_id, e->share_file_id));
 
 		if (!is_valid_share_mode_entry(e)) {
 			continue;
@@ -878,6 +879,7 @@ static struct share_mode_entry *find_share_mode_entry(
 		if (fsp->fh->gen_id != e->share_file_id) {
 			continue;
 		}
+		DEBUG(10, ("Returning share mode entry with gen_id %lu and share_file_id %lu\n", fsp->fh->gen_id, e->share_file_id));
 		return e;
 	}
 	return NULL;
@@ -907,35 +909,33 @@ bool mark_share_mode_disconnected(struct share_mode_lock *lck,
 				  struct files_struct *fsp)
 {
 	struct share_mode_entry *e;
-
-	if (lck->data->num_share_modes != 1) {
-		return false;
-	}
+	bool foundone = false;
 
 	if (fsp->op == NULL) {
 		return false;
 	}
-	if (!fsp->op->global->durable) {
-		return false;
-	}
-
-	e = find_share_mode_entry(lck, fsp);
-	if (e == NULL) {
+	if (!(fsp->op->global->durable || fsp->op->global->resilient)) {
 		return false;
 	}
 
-	DEBUG(10, ("Marking share mode entry disconnected for durable handle\n"));
-
-	server_id_set_disconnected(&e->pid);
-
-	/*
-	 * On reopen the caller needs to check that
-	 * the client comes with the correct handle.
-	 */
-	e->share_file_id = fsp->op->global->open_persistent_id;
-
-	lck->data->modified = true;
-	return true;
+       while (e = find_share_mode_entry(lck, fsp)) {
+               foundone = true;
+               DEBUG(10, ("Marking share mode entry disconnected for durable handle\n"));
+               server_id_set_disconnected(&e->pid);
+               /*
+               * On reopen the caller needs to check that
+               * the client comes with the correct handle.
+               */
+               e->share_file_id = fsp->op->global->open_persistent_id;
+
+               lck->data->modified = true;
+       }
+
+       if (foundone == true) {
+               return true;
+       } else {
+               return false;
+       }
 }
 
 /*******************************************************************
diff --git a/source3/locking/proto.h b/source3/locking/proto.h
index 8ff1c7c..c780a07 100644
--- a/source3/locking/proto.h
+++ b/source3/locking/proto.h
@@ -209,6 +209,7 @@ int share_entry_forall(int (*fn)(const struct share_mode_entry *,
 bool share_mode_cleanup_disconnected(struct file_id id,
 				     uint64_t open_persistent_id);
 
+bool has_connected_share_mode(struct file_id id);
 
 /* The following definitions come from locking/posix.c  */
 
diff --git a/source3/locking/share_mode_lock.c b/source3/locking/share_mode_lock.c
index fe105e3..abec959 100644
--- a/source3/locking/share_mode_lock.c
+++ b/source3/locking/share_mode_lock.c
@@ -814,6 +814,7 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 				  (data->stream_name == NULL)
 				  ? "" : data->stream_name,
 				  server_id_str_buf(entry->pid, &tmp)));
+			/* Cannot cleanup share mode lock as a valid entry exists. */
 			goto done;
 		}
 		if (open_persistent_id != entry->share_file_id) {
@@ -832,6 +833,7 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 				  ? "" : data->stream_name,
 				  (unsigned long long)entry->share_file_id,
 				  (unsigned long long)open_persistent_id));
+			/* Cannot cleanup share mode lock as a valid entry exists. */
 			goto done;
 		}
 	}
@@ -861,6 +863,7 @@ bool share_mode_cleanup_disconnected(struct file_id fid,
 			   (data->stream_name == NULL)
 			   ? "" : data->stream_name,
 			   (unsigned long long)open_persistent_id));
+		/* Cannot cleanup share mode lock as a valid entry exists. */
 		goto done;
 	}
 
@@ -888,3 +891,36 @@ done:
 	talloc_free(frame);
 	return ret;
 }
+
+
+bool has_connected_share_mode(struct file_id fid)
+{
+	bool ret = false;
+	TALLOC_CTX *frame = talloc_stackframe();
+	unsigned n;
+	struct share_mode_data *data;
+	struct share_mode_lock *lck;
+	bool ok;
+
+	lck = get_existing_share_mode_lock(frame, fid);
+	if (lck == NULL) {
+		DEBUG(5, ("has_connected_share_mode: "
+			  "Could not fetch share mode entry for %s\n",
+			  file_id_string(frame, &fid)));
+		goto done;
+	}
+	data = lck->data;
+
+	for (n=0; n < data->num_share_modes; n++) {
+		struct share_mode_entry *entry = &data->share_modes[n];
+
+		if (!server_id_is_disconnected(&entry->pid)) {
+			/* This is a valid (reconnected) entry */
+			ret = true;
+			goto done;
+		}
+	}
+done:
+	talloc_free(frame);
+	return ret;
+}
diff --git a/source3/smbd/close.c b/source3/smbd/close.c
index 1cb5460..db004e0 100644
--- a/source3/smbd/close.c
+++ b/source3/smbd/close.c
@@ -658,7 +658,7 @@ static NTSTATUS close_normal_file(struct smb_request *req, files_struct *fsp,
 	status = ntstatus_keeperror(status, tmp);
 
 	if (NT_STATUS_IS_OK(status) && fsp->op != NULL) {
-		is_durable = fsp->op->global->durable;
+		is_durable = fsp->op->global->durable || fsp->op->global->resilient;
 	}
 
 	if (close_type != SHUTDOWN_CLOSE) {
@@ -724,6 +724,7 @@ static NTSTATUS close_normal_file(struct smb_request *req, files_struct *fsp,
 		 * Make sure the handle is not marked as durable anymore
 		 */
 		fsp->op->global->durable = false;
+		fsp->op->global->resilient = false;
 	}
 
 	if (fsp->print_file) {
diff --git a/source3/smbd/durable.c b/source3/smbd/durable.c
index d9b88a8..4f322a9 100644
--- a/source3/smbd/durable.c
+++ b/source3/smbd/durable.c
@@ -169,7 +169,11 @@ NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
 	}
 
 	if ((fsp_lease_type(fsp) & SMB2_LEASE_HANDLE) == 0) {
+            if ( fsp->op->global->durable ) {
 		return NT_STATUS_NOT_SUPPORTED;
+            } else {
+		DEBUG(3, ("vfs_default_durable_disconnect: Ignoring the fact that no lease held. Continuing with durable disconnect"));
+            }
 	}
 
 	/*
@@ -235,10 +239,15 @@ NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
 			TALLOC_FREE(lck);
 		}
 	}
-	if (lck == NULL) {
-		return NT_STATUS_NOT_SUPPORTED;
+	if ( lck == NULL ) {
+            if ( fsp->op->global->durable ) {
+	        return NT_STATUS_NOT_SUPPORTED;
+            } else {
+                DEBUG(1, ("vfs_default_durable_disconnect: Ignoring share mode lock check and continuing with durable disconnect\n"));
+            }
 	}
-	TALLOC_FREE(lck);
+
+        if ( lck ) TALLOC_FREE(lck);
 
 	status = vfs_stat_fsp(fsp);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -550,7 +559,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	struct files_struct *fsp = NULL;
 	NTSTATUS status;
 	bool ok;
-	int ret;
+	int ret,i;
 	int flags = 0;
 	struct file_id file_id;
 	struct smb_filename *smb_fname = NULL;
@@ -627,49 +636,49 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	 */
 
 	lck = get_existing_share_mode_lock(mem_ctx, file_id);
-	if (lck == NULL) {
-		DEBUG(5, ("vfs_default_durable_reconnect: share-mode lock "
-			   "not obtained from db\n"));
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-	}
-
-	if (lck->data->num_share_modes == 0) {
-		DEBUG(1, ("vfs_default_durable_reconnect: Error: no share-mode "
-			  "entry in existing share mode lock\n"));
-		TALLOC_FREE(lck);
-		return NT_STATUS_INTERNAL_DB_ERROR;
-	}
-
-	if (lck->data->num_share_modes > 1) {
-		/*
-		 * It can't be durable if there is more than one handle
-		 * on the file.
-		 */
-		DEBUG(5, ("vfs_default_durable_reconnect: more than one "
-			  "share-mode entry - can not be durable\n"));
-		TALLOC_FREE(lck);
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-	}
 
-	e = &lck->data->share_modes[0];
-
-	if (!server_id_is_disconnected(&e->pid)) {
-		DEBUG(5, ("vfs_default_durable_reconnect: denying durable "
-			  "reconnect for handle that was not marked "
-			  "disconnected (e.g. smbd or cluster node died)\n"));
-		TALLOC_FREE(lck);
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-	}
-
-	if (e->share_file_id != op->global->open_persistent_id) {
-		DEBUG(5, ("vfs_default_durable_reconnect: denying durable "
-			  "share_file_id changed %llu != %llu"
-			  "(e.g. another client had opened the file)\n",
-			  (unsigned long long)e->share_file_id,
-			  (unsigned long long)op->global->open_persistent_id));
-		TALLOC_FREE(lck);
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-	}
+        if (lck == NULL) {
+                if ( op->global->durable ) {
+                       DEBUG(3, ("vfs_default_durable_reconnect: share-mode lock "
+                               "not obtained from db\n"));
+                       return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+                } else {
+                       DEBUG(3, ("vfs_default_durable_reconnect: share-mode lock "
+                               "not obtained from db, Ignoring...\n"));
+                       goto PROCEEDOPEN;
+                }
+        }
+
+        if (lck->data->num_share_modes == 0) {
+                if ( op->global->durable ) {
+                       DEBUG(1, ("vfs_default_durable_reconnect: Error: no share-mode "
+                               "entry in existing share mode lock\n"));
+                       TALLOC_FREE(lck);
+                       return NT_STATUS_INTERNAL_DB_ERROR;
+                } else {
+                       DEBUG(1, ("vfs_default_durable_reconnect: Error: no share-mode "
+                               "entry in existing share mode lock, Ignoring...\n"));
+                       goto PROCEEDOPEN;
+                }
+        }
+
+        for (i=0; i<lck->data->num_share_modes; i++) {
+                e = &lck->data->share_modes[i];
+                DEBUG(10, ("vfs_default_durable_reconnect: Processing share mode entry with inode %lu and share_file_id %lu\n", file_id.inode, e->share_file_id));
+                if (e->share_file_id != op->global->open_persistent_id) {
+                       /* When a share mode entry is marked disconnected, the share_file_id is set to open_persistent_id*/
+                       /* This could have been a share mode entry already reconnected */
+                       e = NULL;
+                       continue;
+                }
+                DEBUG(10, ("vfs_default_durable_reconnect: Matched share mode entry with inode %lu and share_file_id %lu\n", file_id.inode, e->share_file_id));
+	        break;
+        }
+        if ( e == NULL ) {
+                DEBUG(3, ("vfs_default_durable_reconnect: denying durable reconnect as no share mode entries available to reconnect\n"));
+                TALLOC_FREE(lck);
+                return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+        }
 
 	if ((e->access_mask & (FILE_WRITE_DATA|FILE_APPEND_DATA)) &&
 	    !CAN_WRITE(conn))
@@ -684,12 +693,12 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	/*
 	 * 2. proceed with opening file
 	 */
-
+PROCEEDOPEN:
 	status = fsp_new(conn, conn, &fsp);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("vfs_default_durable_reconnect: failed to create "
 			  "new fsp: %s\n", nt_errstr(status)));
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		return status;
 	}
 
@@ -733,7 +742,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 
 		fsp->lease = find_fsp_lease(fsp, &key, l);
 		if (fsp->lease == NULL) {
-			TALLOC_FREE(lck);
+			if (lck) TALLOC_FREE(lck);
 			fsp_free(fsp);
 			return NT_STATUS_NO_MEMORY;
 		}
@@ -744,7 +753,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 		 */
 		if (!GUID_equal(fsp_client_guid(fsp),
 				&l->client_guid)) {
-			TALLOC_FREE(lck);
+			if (lck) TALLOC_FREE(lck);
 			fsp_free(fsp);
 			return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 		}
@@ -759,7 +768,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 
 	status = fsp_set_smb_fname(fsp, smb_fname);
 	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		fsp_free(fsp);
 		DEBUG(0, ("vfs_default_durable_reconnect: "
 			  "fsp_set_smb_fname failed: %s\n",
@@ -780,7 +789,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 		DEBUG(1, ("vfs_default_durable_reconnect: "
 			  "failed to reopen brlocks: %s\n",
 			  nt_errstr(status)));
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		op->compat = NULL;
 		fsp_free(fsp);
 		return status;
@@ -799,7 +808,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 
 	status = fd_open(conn, fsp, flags, 0 /* mode */);
 	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		DEBUG(1, ("vfs_default_durable_reconnect: failed to open "
 			  "file: %s\n", nt_errstr(status)));
 		op->compat = NULL;
@@ -828,7 +837,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 				  "SMB_VFS_CLOSE failed (%s) - leaking file "
 				  "descriptor\n", strerror(errno)));
 		}
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		op->compat = NULL;
 		fsp_free(fsp);
 		return status;
@@ -841,7 +850,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 				  "SMB_VFS_CLOSE failed (%s) - leaking file "
 				  "descriptor\n", strerror(errno)));
 		}
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		op->compat = NULL;
 		fsp_free(fsp);
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
@@ -855,23 +864,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 				  "SMB_VFS_CLOSE failed (%s) - leaking file "
 				  "descriptor\n", strerror(errno)));
 		}
-		TALLOC_FREE(lck);
-		op->compat = NULL;
-		fsp_free(fsp);
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-	}
-
-	ok = vfs_default_durable_reconnect_check_stat(&cookie.stat_info,
-						      &fsp->fsp_name->st,
-						      fsp_str_dbg(fsp));
-	if (!ok) {
-		ret = SMB_VFS_CLOSE(fsp);
-		if (ret == -1) {
-			DEBUG(0, ("vfs_default_durable_reconnect: "
-				  "SMB_VFS_CLOSE failed (%s) - leaking file "
-				  "descriptor\n", strerror(errno)));
-		}
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		op->compat = NULL;
 		fsp_free(fsp);
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
@@ -887,7 +880,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 				  "SMB_VFS_CLOSE failed (%s) - leaking file "
 				  "descriptor\n", strerror(errno)));
 		}
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		op->compat = NULL;
 		fsp_free(fsp);
 		return status;
@@ -895,7 +888,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 
 	status = vfs_default_durable_cookie(fsp, mem_ctx, &new_cookie_blob);
 	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(lck);
+		if (lck) TALLOC_FREE(lck);
 		DEBUG(1, ("vfs_default_durable_reconnect: "
 			  "vfs_default_durable_cookie - %s\n",
 			  nt_errstr(status)));
@@ -913,8 +906,10 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	/*
 	 * release the sharemode lock: this writes the changes
 	 */
-	lck->data->modified = true;
-	TALLOC_FREE(lck);
+	if (lck) {
+		lck->data->modified = true;
+		TALLOC_FREE(lck);
+	}
 
 	*result = fsp;
 	*new_cookie = new_cookie_blob;
diff --git a/source3/smbd/files.c b/source3/smbd/files.c
index 8fefddd..47a18c4 100644
--- a/source3/smbd/files.c
+++ b/source3/smbd/files.c
@@ -162,6 +162,12 @@ void file_close_conn(connection_struct *conn)
 			 */
 			fsp->op->global->durable = false;
 		}
+		if (fsp->op != NULL && fsp->op->global->resilient) {
+			/*
+			 * A tree disconnect closes a resilient handle
+			 */
+			fsp->op->global->resilient = false;
+		}
 		close_file(NULL, fsp, SHUTDOWN_CLOSE);
 	}
 }
diff --git a/source3/smbd/globals.h b/source3/smbd/globals.h
index 1ca1389..4e1e8a2 100644
--- a/source3/smbd/globals.h
+++ b/source3/smbd/globals.h
@@ -653,6 +653,7 @@ NTSTATUS smbXsrv_open_global_traverse(
 	void *private_data);
 
 NTSTATUS smbXsrv_open_cleanup(uint64_t persistent_id);
+bool smbXsrv_open_is_resilient(uint64_t persistent_id);
 bool smbXsrv_is_encrypted(uint8_t encryption_flags);
 bool smbXsrv_is_partially_encrypted(uint8_t encryption_flags);
 bool smbXsrv_set_crypto_flag(uint8_t *flags, uint8_t flag);
diff --git a/source3/smbd/oplock.c b/source3/smbd/oplock.c
index 4f108d9..e75efaa 100644
--- a/source3/smbd/oplock.c
+++ b/source3/smbd/oplock.c
@@ -187,11 +187,9 @@ bool update_num_read_oplocks(files_struct *fsp, struct share_mode_lock *lck)
 	uint32_t i;
 
 	if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
-		/*
-		 * If we're the only one, we don't need a brlock entry
-		 */
-		SMB_ASSERT(d->num_share_modes == 1);
-		SMB_ASSERT(EXCLUSIVE_OPLOCK_TYPE(d->share_modes[0].op_type));
+                if (d->num_share_modes != 1 || !EXCLUSIVE_OPLOCK_TYPE(d->share_modes[0].op_type)) {
+                       DEBUG(1,("update_num_read_oplocks: num_share_modes = %d\n",d->num_share_modes));
+                }
 		return true;
 	}
 
diff --git a/source3/smbd/scavenger.c b/source3/smbd/scavenger.c
index 9f58f62..48bd795 100644
--- a/source3/smbd/scavenger.c
+++ b/source3/smbd/scavenger.c
@@ -475,17 +475,29 @@ static void scavenger_timer(struct tevent_context *ev,
 	struct scavenger_timer_context *ctx =
 		talloc_get_type_abort(data, struct scavenger_timer_context);
 	NTSTATUS status;
-	bool ok;
+	bool ok, resilient, connected_share_modes;
+
+	resilient = smbXsrv_open_is_resilient(ctx->msg.open_persistent_id);
+	connected_share_modes = has_connected_share_mode(ctx->msg.file_id);
 
-	DEBUG(10, ("scavenger: do cleanup for file %s at %s\n",
+	DEBUG(2, ("scavenger: do cleanup for file %s at %s\n",
 		  file_id_string_tos(&ctx->msg.file_id),
 		  timeval_string(talloc_tos(), &t, true)));
 
+	if ( resilient && connected_share_modes) {
+		/* This is a resilient handle and there is another durable handle that has already */
+		/* been reconnected. Skip cleanup. If this resilient handle is not reconnected, it */
+		/* will be cleaned up when the session closes.					   */
+		DEBUG(2, ("scavenger: skipping cleanup for resilient file with connected sharemode\n"));
+		return;
+	}
+
 	ok = share_mode_cleanup_disconnected(ctx->msg.file_id,
 					     ctx->msg.open_persistent_id);
+	/* The previous function returns an error if it sees other share mode entries */
 	if (!ok) {
 		DEBUG(2, ("Failed to cleanup share modes and byte range locks "
-			  "for file %s open %llu\n",
+			  "for file %s open %llu, proceeding with open cleanup\n",
 			  file_id_string_tos(&ctx->msg.file_id),
 			  (unsigned long long)ctx->msg.open_persistent_id));
 	}
@@ -508,7 +520,7 @@ static void scavenger_add_timer(struct smbd_scavenger_state *state,
 
 	nttime_to_timeval(&until, msg->until);
 
-	DEBUG(10, ("scavenger: schedule file %s for cleanup at %s\n",
+	DEBUG(2, ("scavenger: schedule file %s for cleanup at %s\n",
 		   file_id_string_tos(&msg->file_id),
 		   timeval_string(talloc_tos(), &until, true)));
 
diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index 9cb7197..632dde9 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -670,7 +670,6 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 		struct GUID *create_guid = NULL;
 		bool update_open = false;
 		bool durable_requested = false;
-		bool persistent_handle_requested = false;
 		uint32_t durable_timeout_msec = 0;
 		bool do_durable_reconnect = false;
 		uint64_t persistent_id = 0;
@@ -786,7 +785,6 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 		if (dh2q) {
 			const uint8_t *p = dh2q->data.data;
 			uint32_t durable_v2_timeout = 0;
-			uint32_t durable_v2_flags = 0;
 			DATA_BLOB create_guid_blob;
 
 			if (dh2q->data.length != 32) {
@@ -800,11 +798,6 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			}
 
 			durable_v2_timeout = IVAL(p, 0);
-			durable_v2_flags = IVAL(p, 1);
-
-			if (durable_v2_flags | SMB2_DHANDLE_FLAG_PERSISTENT ) {
-				persistent_handle_requested = true;
-			}
 			create_guid_blob = data_blob_const(p + 16, 16);
 
 			status = GUID_from_ndr_blob(&create_guid_blob,
@@ -958,9 +951,9 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 
 			DEBUG(10, ("smb2_create_send: %s to recreate the "
 				   "smb2srv_open struct for a durable handle.\n",
-				   op->global->durable ? "succeded" : "failed"));
+				   (op->global->durable || op->global->resilient) ? "succeded" : "failed"));
 
-			if (!op->global->durable) {
+			if (!(op->global->durable || op->global->resilient)) {
 				talloc_free(op);
 				tevent_req_nterror(req,
 					NT_STATUS_OBJECT_NAME_NOT_FOUND);
@@ -1162,8 +1155,18 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 		}
 		if (op->global->backend_cookie.length > 0) {
 			update_open = true;
-
-			op->global->durable = true;
+                        /*
+                         * Ashok:  earlier, we use op->global->durable (or resilient)
+                         *         when we're doing a durable reconnect, so I think
+                         *         'durable' is already appropriately set in that case.
+                         *         Therefore, I'm thinking we only want to set
+                         *         'durable' here if we're newly requesting a 
+                         *         a durable handle (otherwise, we might set it on
+                         *         a resilient handle).
+                         */
+                        if (durable_requested) { 
+			        op->global->durable = true;
+                        }
 			op->global->durable_timeout_msec = durable_timeout_msec;
 		}
 
diff --git a/source3/smbd/smb2_ioctl_network_fs.c b/source3/smbd/smb2_ioctl_network_fs.c
index f3d65d4..2f75eea 100644
--- a/source3/smbd/smb2_ioctl_network_fs.c
+++ b/source3/smbd/smb2_ioctl_network_fs.c
@@ -620,33 +620,67 @@ static NTSTATUS fsctl_srv_req_resume_key(TALLOC_CTX *mem_ctx,
 	return NT_STATUS_OK;
 }
 
-static NTSTATUS fsctl_lmr_req_resiliency(TALLOC_CTX *mem_ctx,
-                                        struct tevent_context *ev,
+
+static NTSTATUS fsctl_request_resiliency(struct smbXsrv_connection *conn,
                                         struct files_struct *fsp,
-                                        DATA_BLOB *in_input,
-                                        uint32_t in_max_output,
-                                        DATA_BLOB *out_output)
+                                        DATA_BLOB *in_input)
 {
-       struct req_resume_key_rsp rkey_rsp;
-       enum ndr_err_code ndr_ret;
-       struct network_resiliency_request *lmr_req;
+       NTSTATUS status;
+       uint32_t timeout = 0;
        struct smbXsrv_open *op = fsp->op;
-       NTSTATUS status = NT_STATUS_OK;
 
-       if (in_max_output != 0) {
-               DEBUG(10, ("Invalid output size %d\n", in_max_output));
+       /* Should we check whether fsp is NULL? */
+
+       timeout = IVAL(in_input->data, 0x00);
+       /*
+        * Maximum value should be configurable -
+        * MaxResiliencyTimeout, with a default in
+        * Windows of 300 sec according to [MS-SMB2] 3.3.3
+        */
+       if (timeout > 300 * 1000) {
                return NT_STATUS_INVALID_PARAMETER;
        }
 
-       lmr_req = (struct network_resiliency_request *)in_input->data;
+       if (op->global->backend_cookie.length == 0) {
+               status = SMB_VFS_DURABLE_COOKIE(fsp, op,
+                                               &op->global->backend_cookie);
+               if (!NT_STATUS_IS_OK(status)) {
+                       return status;
+               }
+       }
 
-       DEBUG(10, ("Setting timeout to %u\n", lmr_req->timeout));
+       op->global->durable = false;
+       op->global->resilient = true;
+
+       if (timeout == 0) {
+               /* Default - 120 sec as per Server 2012 and later
+                * according to [MS-SMB2] 3.3.5.15.9
+                */
+               timeout = 120 * 1000;
+       }
+
+       /* [MS-SMB2] defines different state variables for durable
+        * and resilient, but at the same time durable and resilient
+        * are mutually-exclusive, and the scavenging algorithm is
+        * identical.
+        * Therefore we keep the timeout in durable_timeout_msec.
+        */
+       op->global->durable_timeout_msec = timeout;
+
+       /* no need to handle durable owner - it's recorded
+        * on every open even if the handle is not durable
+        * or resilient.
+       */
 
-       op->global->durable_timeout_msec = lmr_req->timeout;
        status = smbXsrv_open_update(op);
-       DEBUG(10, ("smbXsrv_open_update returning %s\n", nt_errstr(status)));
+       DBG_DEBUG("smb2_create_send: smbXsrv_open_update "
+                 "returned %s\n",
+                 nt_errstr(status));
+       if (!NT_STATUS_IS_OK(status)) {
+               return status;
+       }
 
-       return status;
+       return NT_STATUS_OK;
 }
 
 static void smb2_ioctl_network_fs_copychunk_done(struct tevent_req *subreq);
@@ -728,10 +762,8 @@ struct tevent_req *smb2_ioctl_network_fs(uint32_t ctl_code,
 		return tevent_req_post(req, ev);
 		break;
        case FSCTL_LMR_REQ_RESILIENCY:
-               status = fsctl_lmr_req_resiliency(state, ev, state->fsp,
-                                                 &state->in_input,
-                                                 state->in_max_output,
-                                                 &state->out_output);
+               status = fsctl_request_resiliency(state->smbreq->xconn,
+                                                state->fsp, &state->in_input);
                if (!tevent_req_nterror(req, status)) {
                        tevent_req_done(req);
                }
diff --git a/source3/smbd/smb2_negprot.c b/source3/smbd/smb2_negprot.c
index 1146813..0bb13bc 100644
--- a/source3/smbd/smb2_negprot.c
+++ b/source3/smbd/smb2_negprot.c
@@ -310,13 +310,6 @@ NTSTATUS smbd_smb2_request_process_negprot(struct smbd_smb2_request *req)
 		capabilities |= SMB2_CAP_ENCRYPTION;
 	}
 
-        /* Ashok: Advertise persistent handles capability */
-        if (protocol >= PROTOCOL_SMB3_00) {
-               if (in_capabilities & SMB2_CAP_PERSISTENT_HANDLES) {
-                       capabilities |= SMB2_CAP_PERSISTENT_HANDLES;
-               }
-        }
-
 	/*
 	 * 0x10000 (65536) is the maximum allowed message size
 	 * for SMB 2.0
diff --git a/source3/smbd/smb2_tcon.c b/source3/smbd/smb2_tcon.c
index 8072ea6..61e2a36 100644
--- a/source3/smbd/smb2_tcon.c
+++ b/source3/smbd/smb2_tcon.c
@@ -377,12 +377,6 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 		*out_share_flags |= SMB2_SHAREFLAG_ENCRYPT_DATA;
 	}
 
-	/* Ashok SVT hack: Just clain CA capability and Scaleout */
-	if ( conn->protocol >= PROTOCOL_SMB3_00) {
-		*out_capabilities |= SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY;
-		*out_capabilities |= SMB2_SHARE_CAP_SCALEOUT;
-	}
-
 	*out_maximal_access = tcon->compat->share_access;
 
 	*out_tree_id = tcon->global->tcon_wire_id;
diff --git a/source3/smbd/smbXsrv_open.c b/source3/smbd/smbXsrv_open.c
index 1fe8b1b..cbe623f 100644
--- a/source3/smbd/smbXsrv_open.c
+++ b/source3/smbd/smbXsrv_open.c
@@ -998,7 +998,7 @@ NTSTATUS smbXsrv_open_close(struct smbXsrv_open *op, NTTIME now)
 		}
 	}
 
-	if (global_rec != NULL && op->global->durable) {
+	if (global_rec != NULL && ((op->global->durable) || (op->global->resilient))) {
 		/*
 		 * If it is a durable open we need to update the global part
 		 * instead of deleting it
@@ -1242,7 +1242,7 @@ NTSTATUS smb2srv_open_recreate(struct smbXsrv_connection *conn,
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
 
-	if (!op->global->durable) {
+	if (!((op->global->durable) || (op->global->resilient))) {
 		TALLOC_FREE(op);
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
@@ -1485,3 +1485,51 @@ done:
 	talloc_free(frame);
 	return status;
 }
+
+bool smbXsrv_open_is_resilient(uint64_t persistent_id)
+{
+	NTSTATUS status = NT_STATUS_OK;
+	bool ret = false;
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct smbXsrv_open_global0 *op = NULL;
+	uint8_t key_buf[SMBXSRV_OPEN_GLOBAL_TDB_KEY_SIZE];
+	TDB_DATA key;
+	TDB_DATA val;
+	struct db_record *rec;
+	uint32_t global_id = persistent_id & UINT32_MAX;
+
+	key = smbXsrv_open_global_id_to_key(global_id, key_buf);
+	rec = dbwrap_fetch_locked(smbXsrv_open_global_db_ctx, frame, key);
+	if (rec == NULL) {
+		status = NT_STATUS_NOT_FOUND;
+		DEBUG(1, ("smbXsrv_open_is_resilient[global: 0x%08x] "
+			  "failed to fetch record from %s - %s\n",
+			   global_id, dbwrap_name(smbXsrv_open_global_db_ctx),
+			   nt_errstr(status)));
+		goto done;
+	}
+
+	val = dbwrap_record_get_value(rec);
+	if (val.dsize == 0) {
+		DEBUG(1, ("smbXsrv_open_is_resilient[global: 0x%08x] "
+			  "empty record in %s, skipping...\n",
+			   global_id, dbwrap_name(smbXsrv_open_global_db_ctx)));
+		goto done;
+	}
+
+	status = smbXsrv_open_global_parse_record(talloc_tos(), rec, &op);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(1, ("smbXsrv_open_is_resilient[global: 0x%08x] "
+			  "failed to read record: %s\n",
+			  global_id, nt_errstr(status)));
+		goto done;
+	}
+
+	if ( op->resilient ) {
+		DEBUG(1, ("smbXsrv_open_is_resilient[global: 0x%08x], [persistent: 0x%16lx] is resilient\n", global_id, persistent_id));
+		ret = true;
+	}
+done:
+	talloc_free(frame);
+	return ret;
+}
diff --git a/source3/smbd/smbXsrv_session.c b/source3/smbd/smbXsrv_session.c
index 732388b..7cc1a01 100644
--- a/source3/smbd/smbXsrv_session.c
+++ b/source3/smbd/smbXsrv_session.c
@@ -934,6 +934,10 @@ struct tevent_req *smb2srv_session_close_previous_send(TALLOC_CTX *mem_ctx,
 	uint8_t key_buf[SMBXSRV_SESSION_GLOBAL_TDB_KEY_SIZE];
 	TDB_DATA key;
 
+	DEBUG(2,("smb2srv_session_close_previous_send: called with global_id 0x%08x"
+			" previous session id 0x%16lx current session id 0x%16lx\n",
+				global_id,previous_session_id,current_session_id));
+
 	req = tevent_req_create(mem_ctx, &state,
 				struct smb2srv_session_close_previous_state);
 	if (req == NULL) {
diff --git a/source4/torture/smb2/durable_v2_open.c b/source4/torture/smb2/durable_v2_open.c
index f715f9e..18dbc71 100644
--- a/source4/torture/smb2/durable_v2_open.c
+++ b/source4/torture/smb2/durable_v2_open.c
@@ -18,7 +18,7 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
-
+#include <unistd.h>
 #include "includes.h"
 #include "libcli/smb2/smb2.h"
 #include "libcli/smb2/smb2_calls.h"
@@ -46,17 +46,22 @@
 #define CHECK_CREATED(__io, __created, __attribute)			\
 	do {								\
 		CHECK_VAL((__io)->out.create_action, NTCREATEX_ACTION_ ## __created); \
-		CHECK_VAL((__io)->out.alloc_size, 0);			\
 		CHECK_VAL((__io)->out.size, 0);				\
 		CHECK_VAL((__io)->out.file_attr, (__attribute));	\
 		CHECK_VAL((__io)->out.reserved2, 0);			\
 	} while(0)
+/*		CHECK_VAL((__io)->out.create_action, NTCREATEX_ACTION_ ## __created); \ */
+/*		CHECK_VAL((__io)->out.alloc_size, 0);			\ */
+/*		CHECK_VAL((__io)->out.size, 0);				\ */
+/*		CHECK_VAL((__io)->out.file_attr, (__attribute));	\ */
+/*		CHECK_VAL((__io)->out.reserved2, 0);			\ */
 
 static struct {
 	int count;
 	struct smb2_close cl;
 } break_info;
 
+
 static void torture_oplock_close_callback(struct smb2_request *req)
 {
 	smb2_close_recv(req, &break_info.cl);
@@ -107,14 +112,24 @@ bool test_durable_v2_open_create_blob(struct torture_context *tctx,
 
 	smb2_util_unlink(tree, fname);
 
-	smb2_oplock_create_share(&io, fname,
-				 smb2_util_share_access(""),
-				 smb2_util_oplock_level("b"));
+//        smb2_generic_create_share(&io,
+//                                  NULL /* lease */, false /* dir */,
+//                                  fname,
+//                                  NTCREATEX_DISP_OPEN,
+//                                  smb2_util_share_access(""),
+//                                  //smb2_util_oplock_level("b"),
+//                                  0, // no oplock
+//                                  0 /* leasekey */, 0 /* leasestate */);
+
+        smb2_oplock_create_share(&io, fname,
+                                 smb2_util_share_access(""),
+                                 smb2_util_oplock_level("b"));
+
 	io.in.durable_open = false;
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -538,7 +553,7 @@ bool test_durable_v2_open_reopen1(struct torture_context *tctx,
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -611,7 +626,7 @@ bool test_durable_v2_open_reopen1a(struct torture_context *tctx,
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -712,7 +727,7 @@ bool test_durable_v2_open_reopen2(struct torture_context *tctx,
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -873,7 +888,7 @@ bool test_durable_v2_open_reopen2b(struct torture_context *tctx,
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -962,7 +977,7 @@ bool test_durable_v2_open_reopen2c(struct torture_context *tctx,
 	io.in.durable_open_v2 = false;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -1046,7 +1061,7 @@ bool test_durable_v2_open_reopen2_lease(struct torture_context *tctx,
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -1293,7 +1308,7 @@ bool test_durable_v2_open_reopen2_lease_v2(struct torture_context *tctx,
 	io.in.durable_open_v2 = true;
 	io.in.persistent_open = false;
 	io.in.create_guid = create_guid;
-	io.in.timeout = UINT32_MAX;
+	io.in.timeout = 30000;
 
 	status = smb2_create(tree, mem_ctx, &io);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -1531,7 +1546,7 @@ bool test_durable_v2_open_set_persistence(struct torture_context *tctx,
        io.in.durable_open_v2 = true;
        io.in.persistent_open = true;
        io.in.create_guid = create_guid_1;
-       io.in.timeout = UINT32_MAX;
+       io.in.timeout = 30000;
 
        status = smb2_create(tree, mem_ctx, &io);
        CHECK_STATUS(status, NT_STATUS_OK);
@@ -1575,6 +1590,522 @@ done:
        return ret;
 }
 
+/*
+ * Test resilient open, disconnect, re-connect
+ */
+
+bool test_durable_v2_resilience(struct torture_context *tctx,
+                                struct smb2_tree *tree)
+{
+       NTSTATUS status;
+       TALLOC_CTX *mem_ctx = talloc_new(tctx);
+       char fname[256];
+       struct smb2_handle _h1;
+       struct smb2_handle _h2;
+       struct smb2_handle _h3;
+       struct smb2_handle *h1 = NULL;
+       struct smb2_handle *h2 = NULL;
+       struct smb2_handle *h3 = NULL;
+       union smb_ioctl ioctl;
+       struct smb2_create io;
+       struct network_resiliency_request lmr_req;
+       bool ret = true;
+       enum ndr_err_code ndr_ret;
+       struct GUID create_guid_1 = GUID_random();
+       struct GUID create_guid_2 = GUID_random();
+       struct GUID create_guid_3 = GUID_random();
+       struct smbcli_options options;
+
+       /* Choose a random name in case the state is left a little funky. */
+       snprintf(fname, 256, "durable_v2_resilience_%s.dat",
+                generate_random_str(tctx, 8));
+
+       options = tree->session->transport->options;
+
+       smb2_util_unlink(tree, fname);
+
+       ZERO_STRUCT(break_info);
+       smb2_generic_create_share(&io, NULL, false, fname, NTCREATEX_DISP_OPEN_IF,
+                                 smb2_util_share_access(""), 0, 0, 0);
+
+       /* Open the same file 3 times. */
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.create_guid = create_guid_1;
+       io.in.share_access =
+                   NTCREATEX_SHARE_ACCESS_DELETE|
+                   NTCREATEX_SHARE_ACCESS_READ|
+                   NTCREATEX_SHARE_ACCESS_WRITE;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       _h1 = io.out.file.handle;
+       h1 = &_h1;
+
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.create_guid = create_guid_2;
+       io.in.share_access =
+                   NTCREATEX_SHARE_ACCESS_DELETE|
+                   NTCREATEX_SHARE_ACCESS_READ|
+                   NTCREATEX_SHARE_ACCESS_WRITE;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       _h2 = io.out.file.handle;
+       h2 = &_h2;
+
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.create_guid = create_guid_3;
+       io.in.share_access =
+                   NTCREATEX_SHARE_ACCESS_DELETE|
+                   NTCREATEX_SHARE_ACCESS_READ|
+                   NTCREATEX_SHARE_ACCESS_WRITE;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       _h3 = io.out.file.handle;
+       h3 = &_h3;
+
+       /*
+        * Now, set resiliency on each session we have to the file...
+        */
+       ZERO_STRUCT(ioctl);
+       ioctl.smb2.level = RAW_IOCTL_SMB2;
+       ioctl.smb2.in.file.handle = _h1;
+       ioctl.smb2.in.function = FSCTL_LMR_REQ_RESILIENCY;
+       ioctl.smb2.in.max_response_size = 0;
+       ioctl.smb2.in.flags = SMB2_IOCTL_FLAG_IS_FSCTL;
+
+       lmr_req.timeout = 30000; /* 30 seconds */
+       lmr_req.reserved = 0;
+
+       ndr_ret = ndr_push_struct_blob(&ioctl.smb2.in.out, mem_ctx, &lmr_req,
+                                (ndr_push_flags_fn_t)ndr_push_network_resiliency_request);
+       torture_assert_ndr_success(tctx, ndr_ret,
+                                "ndr_push_network_resiliency_request");
+
+       status = smb2_ioctl(tree, mem_ctx, &ioctl.smb2);
+       torture_assert_ntstatus_ok(tctx, status, "FSCTL_LMR_REQUEST_RESILIENCY");
+
+       ZERO_STRUCT(ioctl);
+       ioctl.smb2.level = RAW_IOCTL_SMB2;
+       ioctl.smb2.in.file.handle = _h2;
+       ioctl.smb2.in.function = FSCTL_LMR_REQ_RESILIENCY;
+       ioctl.smb2.in.max_response_size = 0;
+       ioctl.smb2.in.flags = SMB2_IOCTL_FLAG_IS_FSCTL;
+
+       lmr_req.timeout = 30000; /* 30 seconds */
+       lmr_req.reserved = 0;
+
+       ndr_ret = ndr_push_struct_blob(&ioctl.smb2.in.out, mem_ctx, &lmr_req,
+                                (ndr_push_flags_fn_t)ndr_push_network_resiliency_request);
+       torture_assert_ndr_success(tctx, ndr_ret,
+                                "ndr_push_network_resiliency_request");
+       status = smb2_ioctl(tree, mem_ctx, &ioctl.smb2);
+       torture_assert_ntstatus_ok(tctx, status, "FSCTL_LMR_REQUEST_RESILIENCY");
+
+       ZERO_STRUCT(ioctl);
+       ioctl.smb2.level = RAW_IOCTL_SMB2;
+       ioctl.smb2.in.file.handle = _h3;
+       ioctl.smb2.in.function = FSCTL_LMR_REQ_RESILIENCY;
+       ioctl.smb2.in.max_response_size = 0;
+       ioctl.smb2.in.flags = SMB2_IOCTL_FLAG_IS_FSCTL;
+
+       lmr_req.timeout = 30000; /* 30 seconds */
+       lmr_req.reserved = 0;
+
+       ndr_ret = ndr_push_struct_blob(&ioctl.smb2.in.out, mem_ctx, &lmr_req,
+                                (ndr_push_flags_fn_t)ndr_push_network_resiliency_request);
+       torture_assert_ndr_success(tctx, ndr_ret,
+                                "ndr_push_network_resiliency_request");
+
+       status = smb2_ioctl(tree, mem_ctx, &ioctl.smb2);
+       torture_assert_ntstatus_ok(tctx, status, "FSCTL_LMR_REQUEST_RESILIENCY");
+
+       /* disconnect, reconnect and then do durable reopen */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+                torture_warning(tctx, "couldn't reconnect, bailing\n");
+                ret = false;
+                goto done;
+       }
+
+       /*
+        * Now for a succeeding reconnect to our first session:
+        */
+       ZERO_STRUCT(io);
+       io.in.fname = fname;
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle = h1;
+       io.in.create_guid = create_guid_1;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+
+       /*
+        * Now for a succeeding reconnect to our second session:
+       */
+       sleep(5);
+       ZERO_STRUCT(io);
+       io.in.fname = fname;
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle = h2;
+       io.in.create_guid = create_guid_2;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+       /* disconnect one more time */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+               torture_warning(tctx, "couldn't reconnect, bailing\n");
+               ret = false;
+               goto done;
+       }
+
+       status = smb2_util_close(tree, *h1);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       status = smb2_util_close(tree, *h2);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       h1 = NULL;
+       h2 = NULL;
+       h3 = NULL;
+
+done:
+       if (h1 != NULL) {
+              smb2_util_close(tree, *h1);
+       }
+       if (h2 != NULL) {
+              smb2_util_close(tree, *h2);
+       }
+       if (h3 != NULL) {
+              smb2_util_close(tree, *h3);
+       }
+       smb2_util_close(tree, io.out.file.handle);
+
+       smb2_util_unlink(tree, fname);
+
+       talloc_free(mem_ctx);
+       return ret;
+}
+
+/*
+ * Test resilient open, disconnect, re-connect
+ */
+
+bool test_durable_v2_resilience_brlock(struct torture_context *tctx,
+                                         struct smb2_tree *tree)
+{
+       NTSTATUS status;
+       TALLOC_CTX *mem_ctx = talloc_new(tctx);
+       char fname[256];
+       struct smb2_handle _h1;
+       struct smb2_handle _h2;
+       struct smb2_handle _h3;
+       struct smb2_handle *h1 = NULL;
+       struct smb2_handle *h2 = NULL;
+       struct smb2_handle *h3 = NULL;
+       union smb_ioctl ioctl;
+       struct smb2_create io;
+       struct network_resiliency_request lmr_req;
+       bool ret = true;
+       enum ndr_err_code ndr_ret;
+       struct GUID create_guid_1 = GUID_random();
+       struct GUID create_guid_2 = GUID_random();
+       struct GUID create_guid_3 = GUID_random();
+       struct smbcli_options options;
+       struct smb2_lock lck;
+       struct smb2_lock_element lock[1];
+       struct smb2_lock lck2;
+       struct smb2_lock_element lock2[1];
+
+       /* Choose a random name in case the state is left a little funky. */
+       snprintf(fname, 256, "durable_v2_resilience_brl_%s.dat",
+                generate_random_str(tctx, 8));
+
+       options = tree->session->transport->options;
+
+       smb2_util_unlink(tree, fname);
+
+       ZERO_STRUCT(break_info);
+       smb2_generic_create_share(&io, NULL, false, fname, NTCREATEX_DISP_OPEN_IF,
+                                 smb2_util_share_access(""), 0, 0, 0);
+
+       /* Open the same file 3 times. */
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.create_guid = create_guid_1;
+       io.in.share_access =
+                NTCREATEX_SHARE_ACCESS_DELETE|
+                NTCREATEX_SHARE_ACCESS_READ|
+                NTCREATEX_SHARE_ACCESS_WRITE;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       _h1 = io.out.file.handle;
+        h1 = &_h1;
+
+       lock[0].offset = 0;
+       lock[0].length = 4;
+       lock[0].flags = SMB2_LOCK_FLAG_SHARED;
+       ZERO_STRUCT(lck);
+       lck.in.file.handle = _h1;
+       lck.in.locks = &lock[0];
+       lck.in.lock_count = 1;
+       status = smb2_lock(tree, &lck);
+       torture_assert_ntstatus_ok(tctx, status, "Incorrect status");
+
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.create_guid = create_guid_2;
+       io.in.share_access =
+                NTCREATEX_SHARE_ACCESS_DELETE|
+                NTCREATEX_SHARE_ACCESS_READ|
+                NTCREATEX_SHARE_ACCESS_WRITE;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       _h2 = io.out.file.handle;
+        h2 = &_h2;
+
+       lock2[0].offset = 5;
+       lock2[0].length = 8;
+       lock2[0].flags = SMB2_LOCK_FLAG_SHARED;
+
+       ZERO_STRUCT(lck2);
+       lck2.in.file.handle = _h2;
+       lck2.in.locks = &lock2[0];
+       lck2.in.lock_count = 1;
+       status = smb2_lock(tree, &lck2);
+       torture_assert_ntstatus_ok(tctx, status, "Incorrect status");
+
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.create_guid = create_guid_3;
+       io.in.share_access =
+                NTCREATEX_SHARE_ACCESS_DELETE|
+                NTCREATEX_SHARE_ACCESS_READ|
+                NTCREATEX_SHARE_ACCESS_WRITE;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       _h3 = io.out.file.handle;
+        h3 = &_h3;
+
+       /*
+        * Now, set resiliency on each session we have to the file...
+        */
+       ZERO_STRUCT(ioctl);
+       ioctl.smb2.level = RAW_IOCTL_SMB2;
+       ioctl.smb2.in.file.handle = _h1;
+       ioctl.smb2.in.function = FSCTL_LMR_REQ_RESILIENCY;
+       ioctl.smb2.in.max_response_size = 0;
+       ioctl.smb2.in.flags = SMB2_IOCTL_FLAG_IS_FSCTL;
+
+       lmr_req.timeout = 30000; /* 30 seconds */
+       lmr_req.reserved = 0;
+
+       ndr_ret = ndr_push_struct_blob(&ioctl.smb2.in.out, mem_ctx, &lmr_req,
+                               (ndr_push_flags_fn_t)ndr_push_network_resiliency_request);
+       torture_assert_ndr_success(tctx, ndr_ret,
+                               "ndr_push_network_resiliency_request");
+
+       status = smb2_ioctl(tree, mem_ctx, &ioctl.smb2);
+       torture_assert_ntstatus_ok(tctx, status, "FSCTL_LMR_REQUEST_RESILIENCY");
+
+       ZERO_STRUCT(ioctl);
+       ioctl.smb2.level = RAW_IOCTL_SMB2;
+       ioctl.smb2.in.file.handle = _h2;
+       ioctl.smb2.in.function = FSCTL_LMR_REQ_RESILIENCY;
+       ioctl.smb2.in.max_response_size = 0;
+       ioctl.smb2.in.flags = SMB2_IOCTL_FLAG_IS_FSCTL;
+
+       lmr_req.timeout = 30000; /* 30 seconds */
+       lmr_req.reserved = 0;
+
+       ndr_ret = ndr_push_struct_blob(&ioctl.smb2.in.out, mem_ctx, &lmr_req,
+                               (ndr_push_flags_fn_t)ndr_push_network_resiliency_request);
+       torture_assert_ndr_success(tctx, ndr_ret,
+                               "ndr_push_network_resiliency_request");
+       status = smb2_ioctl(tree, mem_ctx, &ioctl.smb2);
+       torture_assert_ntstatus_ok(tctx, status, "FSCTL_LMR_REQUEST_RESILIENCY");
+
+       ZERO_STRUCT(ioctl);
+       ioctl.smb2.level = RAW_IOCTL_SMB2;
+       ioctl.smb2.in.file.handle = _h3;
+       ioctl.smb2.in.function = FSCTL_LMR_REQ_RESILIENCY;
+       ioctl.smb2.in.max_response_size = 0;
+       ioctl.smb2.in.flags = SMB2_IOCTL_FLAG_IS_FSCTL;
+
+       lmr_req.timeout = 30000; /* 30 seconds */
+       lmr_req.reserved = 0;
+
+       ndr_ret = ndr_push_struct_blob(&ioctl.smb2.in.out, mem_ctx, &lmr_req,
+                               (ndr_push_flags_fn_t)ndr_push_network_resiliency_request);
+       torture_assert_ndr_success(tctx, ndr_ret,
+                               "ndr_push_network_resiliency_request");
+
+      status = smb2_ioctl(tree, mem_ctx, &ioctl.smb2);
+       torture_assert_ntstatus_ok(tctx, status, "FSCTL_LMR_REQUEST_RESILIENCY");
+
+       /* disconnect, reconnect and then do durable reopen */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+               torture_warning(tctx, "couldn't reconnect, bailing\n");
+               ret = false;
+               goto done;
+       }
+
+       /*
+        * Now for a succeeding reconnect to our first session:
+       */
+       sleep(5);
+      ZERO_STRUCT(io);
+      io.in.fname = fname;
+      io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle = h1;
+       io.in.create_guid = create_guid_1;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+
+       _h1 = io.out.file.handle;
+        h1 = &_h1;
+
+       /*
+        * Now for a succeeding reconnect to our second session:
+       */
+       sleep(5);
+       ZERO_STRUCT(io);
+       io.in.fname = fname;
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle = h2;
+       io.in.create_guid = create_guid_2;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+
+       _h2 = io.out.file.handle;
+        h2 = &_h2;
+
+       /*
+        * Now for a succeeding reconnect to our third session:
+       */
+       sleep(5);
+       ZERO_STRUCT(io);
+       io.in.fname = fname;
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle = h3;
+       io.in.create_guid = create_guid_3;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+       _h3 = io.out.file.handle;
+        h3 = &_h3;
+
+       sleep(5);
+       lock[0].offset = 0;
+       lock[0].length = 4;
+       lock[0].flags = SMB2_LOCK_FLAG_UNLOCK;
+       ZERO_STRUCT(lck);
+       lck.in.file.handle = _h1;
+       lck.in.locks = &lock[0];
+       lck.in.lock_count = 1;
+       status = smb2_lock(tree, &lck);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       lock2[0].offset = 5;
+       lock2[0].length = 8;
+       lock2[0].flags = SMB2_LOCK_FLAG_UNLOCK;
+       ZERO_STRUCT(lck2);
+       lck2.in.file.handle = _h2;
+       lck2.in.locks = &lock2[0];
+       lck2.in.lock_count = 1;
+       status = smb2_lock(tree, &lck2);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       /* disconnect one more time */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+                torture_warning(tctx, "couldn't reconnect, bailing\n");
+                ret = false;
+                goto done;
+       }
+
+       status = smb2_util_close(tree, *h1);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       status = smb2_util_close(tree, *h2);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       status = smb2_util_close(tree, *h3);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       h1 = NULL;
+       h2 = NULL;
+       h3 = NULL;
+
+done:
+       if (h1 != NULL) {
+               smb2_util_close(tree, *h1);
+       }
+       if (h2 != NULL) {
+               smb2_util_close(tree, *h2);
+       }
+       if (h3 != NULL) {
+               smb2_util_close(tree, *h3);
+       }
+       smb2_util_close(tree, io.out.file.handle);
+
+       smb2_util_unlink(tree, fname);
+
+       talloc_free(mem_ctx);
+       return ret;
+}
+
 /**
  * Test durable request / reconnect with AppInstanceId
  */
@@ -1611,7 +2142,7 @@ bool test_durable_v2_open_app_instance(struct torture_context *tctx,
 	io1.in.persistent_open = false;
 	io1.in.create_guid = create_guid_1;
 	io1.in.app_instance_id = &app_instance_id;
-	io1.in.timeout = UINT32_MAX;
+	io1.in.timeout = 30000;
 
 	status = smb2_create(tree1, mem_ctx, &io1);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -1627,7 +2158,7 @@ bool test_durable_v2_open_app_instance(struct torture_context *tctx,
 	/*
 	 * try to open the file as durable from a second tree with
 	 * a different create guid but the same app_instance_id
-	 * while the first handle is still open.
+	* while the first handle is still open.
 	 */
 
 	smb2_oplock_create_share(&io2, fname,
@@ -1638,7 +2169,7 @@ bool test_durable_v2_open_app_instance(struct torture_context *tctx,
 	io2.in.persistent_open = false;
 	io2.in.create_guid = create_guid_2;
 	io2.in.app_instance_id = &app_instance_id;
-	io2.in.timeout = UINT32_MAX;
+	io2.in.timeout = 30000;
 
 	status = smb2_create(tree2, mem_ctx, &io2);
 	CHECK_STATUS(status, NT_STATUS_OK);
@@ -1860,11 +2391,12 @@ struct torture_suite *torture_smb2_durable_v2_open_init(void)
 	torture_suite_add_1smb2_test(suite, "reopen2c", test_durable_v2_open_reopen2c);
 	torture_suite_add_1smb2_test(suite, "reopen2-lease", test_durable_v2_open_reopen2_lease);
 	torture_suite_add_1smb2_test(suite, "reopen2-lease-v2", test_durable_v2_open_reopen2_lease_v2);
-	torture_suite_add_2smb2_test(suite, "app-instance", test_durable_v2_open_app_instance);
+//	torture_suite_add_2smb2_test(suite, "app-instance", test_durable_v2_open_app_instance);
 	torture_suite_add_1smb2_test(suite, "persistent-open-oplock", test_persistent_open_oplock);
 	torture_suite_add_1smb2_test(suite, "persistent-open-lease", test_persistent_open_lease);
 	torture_suite_add_1smb2_test(suite, "persistent-open-set-persistent", test_durable_v2_open_set_persistence);
-
+        torture_suite_add_1smb2_test(suite, "resilience", test_durable_v2_resilience);
+        torture_suite_add_1smb2_test(suite, "resilience-brlock", test_durable_v2_resilience_brlock);
 	suite->description = talloc_strdup(suite, "SMB2-DURABLE-V2-OPEN tests");
 
 	return suite;
