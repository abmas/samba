From: pcerqua <paul.cerqua@simplivity.com>
Date: Mon, 11 Jul 2016 10:59:20 -0400
Subject: HYP-1683: Persist lease information to survive samba restart

---
 source3/librpc/idl/leases_db.idl |  1 +
 source3/locking/leases_db.c      | 95 ++++++++++++++++++++++++++++++++++++++--
 source3/locking/leases_db.h      |  6 ++-
 source3/locking/locking.c        |  6 ++-
 source3/locking/proto.h          |  3 +-
 source3/smbd/open.c              |  3 +-
 source3/smbd/reply.c             |  2 +-
 source3/smbd/smb2_create.c       | 24 +++++++++-
 8 files changed, 128 insertions(+), 12 deletions(-)

diff --git a/source3/librpc/idl/leases_db.idl b/source3/librpc/idl/leases_db.idl
index d021875..fe2a78d 100644
--- a/source3/librpc/idl/leases_db.idl
+++ b/source3/librpc/idl/leases_db.idl
@@ -19,6 +19,7 @@ interface leases_db
 		[string,charset(UTF8)] char *servicepath;
 		[string,charset(UTF8)] char *base_name;
 		[string,charset(UTF8)] char *stream_name;
+		udlong open_persistent_id;
 	} leases_db_file;
 
 	typedef [public] struct {
diff --git a/source3/locking/leases_db.c b/source3/locking/leases_db.c
index 4167ef7..56431f4 100644
--- a/source3/locking/leases_db.c
+++ b/source3/locking/leases_db.c
@@ -33,9 +33,69 @@
 /* the leases database handle */
 static struct db_context *leases_db;
 
+static int leases_db_traverse_persist_fn(struct db_record *rec, void *_state)
+{
+        uint32_t i;
+        TDB_DATA key,data;
+        TDB_DATA value;
+        DATA_BLOB blob;
+        enum ndr_err_code ndr_err;
+        struct leases_db_value *d;
+        bool found_persistent_open = False;
+        NTSTATUS status;
+
+        key = dbwrap_record_get_key(rec);
+        value = dbwrap_record_get_value(rec);
+
+        DEBUG(1, ("leases_db_traverse_persist_fn: Entering leases_db_traverse_persist_fn\n"));
+
+        /* Ensure this is a key record. */
+        if (key.dsize != sizeof(struct leases_db_key)) {
+		DEBUG(1, ("leases_db_traverse_persist_fn: Record is not a key record - key.dsize is %d\n", key.dsize));
+                return 0;
+        }
+
+        d = talloc(talloc_tos(), struct leases_db_value);
+        if (d == NULL) {
+		DEBUG(1, ("leases_db_traverse_persist_fn: talloc failed\n"));
+                return 0;
+        }
+
+        blob.data = value.dptr;
+        blob.length = value.dsize;
+
+	ndr_err = ndr_pull_struct_blob_all(
+		&blob, d, d,
+		(ndr_pull_flags_fn_t)ndr_pull_leases_db_value);
+        if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+                DEBUG(1, ("leases_db_traverse_persist_fn: ndr_pull_lease failed\n"));
+                return 0;
+        }
+
+        for (i=0; i<d->num_files; i++) {
+                DEBUG(1, ("leases_db_traverse_persist_fn: Loop iteration %i\n", i));
+                struct leases_db_file *entry = &d->files[i];
+                if ( entry->open_persistent_id != UINT64_MAX && smbXsrv_lookup_persistent_id(entry->open_persistent_id) ) {
+                        found_persistent_open = True;
+                        DEBUG(1, ("leases_db_traverse_persist_fn: Found a persistent open, retaining record for id %ld\n", entry->open_persistent_id));
+                }
+        }
+
+        if ( !found_persistent_open ) {
+                DEBUG(1, ("leases_db_traverse_persist_fn: Removing record from leases.tdb\n"));
+                dbwrap_record_delete(rec);
+        }
+
+        TALLOC_FREE(d);
+        DEBUG(1, ("leases_db_traverse_persist_fn: Leaving leases_db_traverse_persist_fn\n"));
+
+        return 0;
+}
+
 bool leases_db_init(bool read_only)
 {
 	char *db_path;
+	NTSTATUS status;
 
 	if (leases_db) {
 		return true;
@@ -47,7 +107,7 @@ bool leases_db_init(bool read_only)
 	}
 
 	leases_db = db_open(NULL, db_path, 0,
-			    TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|
+			    TDB_DEFAULT|TDB_VOLATILE|/*TDB_CLEAR_IF_FIRST|*/
 			    TDB_INCOMPATIBLE_HASH,
 			    read_only ? O_RDONLY : O_RDWR|O_CREAT, 0644,
 			    DBWRAP_LOCK_ORDER_2, DBWRAP_FLAG_NONE);
@@ -57,6 +117,28 @@ bool leases_db_init(bool read_only)
 		return false;
 	}
 
+        if ( read_only == false ) {
+                /* traverse the db and only get rid of entries not belonging to a persistent open */
+                status = dbwrap_traverse_read(leases_db, leases_db_traverse_persist_fn, NULL, NULL);
+
+                if ( ! NT_STATUS_IS_OK(status) ) {
+                        TALLOC_FREE(leases_db);
+                        /* Cleanup and move on */
+                        DEBUG(0,("ERROR: Failed to recover persistent handle related lease entries. Cleanup and proceed.\n"));
+                        leases_db = db_open(NULL, db_path, 0,
+                                TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+                                read_only?O_RDONLY:O_RDWR|O_CREAT, 0644,
+                                DBWRAP_LOCK_ORDER_2, DBWRAP_FLAG_NONE);
+                        if (!leases_db) {
+                                DEBUG(0,("ERROR: Failed to initialise lease database\n"));
+                                TALLOC_FREE(db_path);
+                                return False;
+                        }
+                } else {
+                        TALLOC_FREE(db_path);
+                }
+        }
+
 	return true;
 }
 
@@ -94,7 +176,8 @@ NTSTATUS leases_db_add(const struct GUID *client_guid,
 		       const struct file_id *id,
 		       const char *servicepath,
 		       const char *base_name,
-		       const char *stream_name)
+		       const char *stream_name,
+		       uint64_t open_persistent_id)
 {
 	TDB_DATA db_key, db_value;
 	DATA_BLOB blob;
@@ -166,6 +249,7 @@ NTSTATUS leases_db_add(const struct GUID *client_guid,
 		value->files[value->num_files].servicepath = servicepath;
 		value->files[value->num_files].base_name = base_name;
 		value->files[value->num_files].stream_name = stream_name;
+		value->files[value->num_files].open_persistent_id = open_persistent_id;
 		value->num_files += 1;
 
 	} else {
@@ -176,6 +260,7 @@ NTSTATUS leases_db_add(const struct GUID *client_guid,
 			.servicepath = servicepath,
 			.base_name = base_name,
 			.stream_name = stream_name,
+			.open_persistent_id = open_persistent_id,
 		};
 
 		new_value = (struct leases_db_value) {
@@ -406,7 +491,8 @@ NTSTATUS leases_db_rename(const struct GUID *client_guid,
 		       const struct file_id *id,
 		       const char *servicename_new,
 		       const char *filename_new,
-		       const char *stream_name_new)
+		       const char *stream_name_new,
+		       uint64_t open_persistent_id)
 {
 	NTSTATUS status;
 
@@ -422,7 +508,8 @@ NTSTATUS leases_db_rename(const struct GUID *client_guid,
 				id,
 				servicename_new,
 				filename_new,
-				stream_name_new);
+				stream_name_new,
+				open_persistent_id);
 }
 
 NTSTATUS leases_db_copy_file_ids(TALLOC_CTX *mem_ctx,
diff --git a/source3/locking/leases_db.h b/source3/locking/leases_db.h
index 383575a..cba7c52 100644
--- a/source3/locking/leases_db.h
+++ b/source3/locking/leases_db.h
@@ -32,7 +32,8 @@ NTSTATUS leases_db_add(const struct GUID *client_guid,
 		       const struct file_id *id,
 		       const char *servicepath,
 		       const char *filename,
-		       const char *stream_name);
+		       const char *stream_name,
+		       uint64_t open_persistent_id);
 NTSTATUS leases_db_del(const struct GUID *client_guid,
 		       const struct smb2_lease_key *lease_key,
 		       const struct file_id *id);
@@ -47,7 +48,8 @@ NTSTATUS leases_db_rename(const struct GUID *client_guid,
 			const struct file_id *id,
 			const char *servicepath_new,
 			const char *filename_new,
-			const char *stream_name_new);
+			const char *stream_name_new,
+		        uint64_t open_persistent_id);
 NTSTATUS leases_db_copy_file_ids(TALLOC_CTX *mem_ctx,
 			uint32_t num_files,
 			const struct leases_db_file *files,
diff --git a/source3/locking/locking.c b/source3/locking/locking.c
index d6bdb71..cee73b9 100644
--- a/source3/locking/locking.c
+++ b/source3/locking/locking.c
@@ -466,7 +466,8 @@ bool rename_share_filename(struct messaging_context *msg_ctx,
 			const char *servicepath,
 			uint32_t orig_name_hash,
 			uint32_t new_name_hash,
-			const struct smb_filename *smb_fname_dst)
+			const struct smb_filename *smb_fname_dst,
+			uint64_t open_persistent_id)
 {
 	struct share_mode_data *d = lck->data;
 	size_t sp_len;
@@ -582,7 +583,8 @@ bool rename_share_filename(struct messaging_context *msg_ctx,
 					&id,
 					d->servicepath,
 					d->base_name,
-					d->stream_name);
+					d->stream_name,
+					open_persistent_id);
 		if (!NT_STATUS_IS_OK(status)) {
 			/* Any error recovery possible here ? */
 			DEBUG(1,("Failed to rename lease key for "
diff --git a/source3/locking/proto.h b/source3/locking/proto.h
index c780a07..2507b27 100644
--- a/source3/locking/proto.h
+++ b/source3/locking/proto.h
@@ -159,7 +159,8 @@ bool rename_share_filename(struct messaging_context *msg_ctx,
 			const char *servicepath,
 			uint32_t orig_name_hash,
 			uint32_t new_name_hash,
-			const struct smb_filename *smb_fname);
+			const struct smb_filename *smb_fname,
+			uint64_t open_persistent_id);
 void get_file_infos(struct file_id id,
 		    uint32_t name_hash,
 		    bool *delete_on_close,
diff --git a/source3/smbd/open.c b/source3/smbd/open.c
index 61b7145..3af315a 100644
--- a/source3/smbd/open.c
+++ b/source3/smbd/open.c
@@ -1685,7 +1685,8 @@ static NTSTATUS grant_fsp_lease(struct files_struct *fsp,
 			       &fsp->file_id,
 			       fsp->conn->connectpath,
 			       fsp->fsp_name->base_name,
-			       fsp->fsp_name->stream_name);
+			       fsp->fsp_name->stream_name,
+			       fsp->op->global->open_persistent_id);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(10, ("%s: leases_db_add failed: %s\n", __func__,
 			   nt_errstr(status)));
diff --git a/source3/smbd/reply.c b/source3/smbd/reply.c
index bfa64a3..3311854 100644
--- a/source3/smbd/reply.c
+++ b/source3/smbd/reply.c
@@ -6440,7 +6440,7 @@ static void rename_open_files(connection_struct *conn,
 	/* Send messages to all smbd's (not ourself) that the name has changed. */
 	rename_share_filename(conn->sconn->msg_ctx, lck, id, conn->connectpath,
 			      orig_name_hash, new_name_hash,
-			      smb_fname_dst);
+			      smb_fname_dst, fsp->op->global->open_persistent_id);
 
 }
 
diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index 0e5c399..499efd1 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -381,6 +381,19 @@ static NTSTATUS smbd_smb2_create_durable_lease_check(
 	struct smb_filename *smb_fname = NULL;
 	uint32_t ucf_flags = UCF_PREP_CREATEFILE;
 	NTSTATUS status;
+	char *unix_syntax_filename;
+
+	if (requested_filename == NULL) {
+		DEBUG(1, ("smbd_smb2_create_durable_lease_check: requested filename is NULL\n"));
+		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+	}
+
+	unix_syntax_filename = strdup(requested_filename);
+
+	if (unix_syntax_filename == NULL) {
+		DEBUG(1, ("smbd_smb2_create_durable_lease_check: can't dup filename; out of memory\n"));
+		return NT_STATUS_NO_MEMORY;
+	}
 
 	if (lease_ptr == NULL) {
 		if (fsp->oplock_type != LEASE_OPLOCK) {
@@ -403,13 +416,21 @@ static NTSTATUS smbd_smb2_create_durable_lease_check(
 			   "in reopened file\n"));
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
+	status = check_path_syntax(unix_syntax_filename);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(10, ("smbd_smb2_create_durable_lease_check: check_path_syntax returned %s\n",
+			   nt_errstr(status)));
+		free(unix_syntax_filename);
+		return status;
+	}
 
 	status = filename_convert(talloc_tos(), fsp->conn, false,
-				  requested_filename, ucf_flags,
+				  unix_syntax_filename, ucf_flags,
 				  NULL, &smb_fname);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(10, ("filename_convert returned %s\n",
 			   nt_errstr(status)));
+		free(unix_syntax_filename);
 		return status;
 	}
 
@@ -417,6 +438,7 @@ static NTSTATUS smbd_smb2_create_durable_lease_check(
 		DEBUG(10, ("Lease requested for file %s, reopened file "
 			   "is named %s\n", smb_fname->base_name,
 			   fsp->fsp_name->base_name));
+		free(unix_syntax_filename);
 		TALLOC_FREE(smb_fname);
 		return NT_STATUS_INVALID_PARAMETER;
 	}
