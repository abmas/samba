From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Sat, 6 May 2017 20:21:40 +0000
Subject: HYP-4645: Changes to trim db files on samba startup.

---
 lib/tdb_wrap/tdb_wrap.c           | 147 ++++++++++++++++++++++++++++++++++++++
 lib/tdb_wrap/tdb_wrap.h           |   2 +
 source3/locking/brlock.c          |   2 +
 source3/locking/leases_db.c       |   2 +
 source3/locking/share_mode_lock.c |   4 +-
 source3/smbd/smbXsrv_open.c       |   3 +-
 6 files changed, 158 insertions(+), 2 deletions(-)

diff --git a/lib/tdb_wrap/tdb_wrap.c b/lib/tdb_wrap/tdb_wrap.c
index 864656f..ec9e078 100644
--- a/lib/tdb_wrap/tdb_wrap.c
+++ b/lib/tdb_wrap/tdb_wrap.c
@@ -23,6 +23,7 @@
 #include "lib/util/dlinklist.h"
 #include "lib/util/debug.h"
 #include "tdb_wrap.h"
+#include "system/filesys.h"
 
 /*
  Log tdb messages via DEBUG().
@@ -72,6 +73,39 @@ struct tdb_wrap_private {
 	struct tdb_wrap_private *next, *prev;
 };
 
+static int failed;
+
+static int copy_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)
+{
+        TDB_CONTEXT *tdb_new = (TDB_CONTEXT *)state;
+
+        if (tdb_store(tdb_new, key, dbuf, TDB_INSERT) != 0) {
+                DEBUG(0,("TRIMTDB:Failed to insert into %s\n", tdb_name(tdb_new)));
+                failed = 1;
+                return 1;
+        }
+        return 0;
+}
+
+static int dummy_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)
+{
+        return 0;
+}
+
+static char *add_suffix(const char *name, const char *suffix)
+{
+        char *ret;
+        int len = strlen(name) + strlen(suffix) + 1;
+        ret = (char *)malloc(len);
+        if (!ret) {
+                DEBUG(0,("TRIMTDB:Out of memory!\n"));
+                exit(1);
+        }
+        snprintf(ret, len, "%s%s", name, suffix);
+        return ret;
+}
+
+
 static struct tdb_wrap_private *tdb_list;
 
 /* destroy the last connection to a tdb */
@@ -91,6 +125,11 @@ static struct tdb_wrap_private *tdb_wrap_private_open(TALLOC_CTX *mem_ctx,
 {
 	struct tdb_wrap_private *result;
 	struct tdb_logging_context lctx = { .log_fn = tdb_wrap_log };
+	TDB_CONTEXT *tdb;
+	TDB_CONTEXT *tdb_new;
+	char *tmp_name;
+	int count1, count2;
+	struct stat st;
 
 	result = talloc_pooled_object(mem_ctx, struct tdb_wrap_private,
 				      1, strlen(name)+1);
@@ -105,6 +144,114 @@ static struct tdb_wrap_private *tdb_wrap_private_open(TALLOC_CTX *mem_ctx,
 	if (result->tdb == NULL) {
 		goto fail;
 	}
+	tdb = result->tdb;
+	if ( (tdb_flags & TDB_TRIM_SIZE) == TDB_TRIM_SIZE) {
+		if (stat(name, &st) == 0) {
+			DEBUG(0,("TDBTRIM: Size of tdb %s before trim = %u\n",name,(uint32_t)st.st_size));
+		}
+		tmp_name = add_suffix(name, ".tmp");
+		unlink(tmp_name);
+		tdb_new = tdb_open_ex(tmp_name,
+				hash_size,
+				tdb_flags|TDB_NOMMAP,
+				open_flags, mode,
+				&lctx, NULL);
+		if (!tdb_new) {
+			DEBUG(0,("TDBTRIM:Unable to open file %s\n",tmp_name));
+			free(tmp_name);
+			goto cont;
+		}
+		if (tdb_transaction_start(tdb) != 0) {
+			DEBUG(0,("TDBTRIM:Failed to start transaction on original tdb\n"));
+			tdb_close(tdb_new);
+			unlink(tmp_name);
+			free(tmp_name);
+			goto cont;
+		}
+		/* lock the backup tdb so that nobody else can change it */
+		if (tdb_lockall(tdb_new) != 0) {
+			DEBUG(0,("TDBTRIM:Failed to lock backup tdb\n"));
+			tdb_close(tdb_new);
+			unlink(tmp_name);
+			free(tmp_name);
+			if (tdb_transaction_cancel(tdb) != 0 ) goto fail;
+			goto cont;
+		}
+
+		failed = 0;
+
+		/* traverse and copy */
+		count1 = tdb_traverse(tdb, copy_fn, (void *)tdb_new);
+		if (count1 < 0 || failed) {
+			DEBUG(0,("TDBTRIM:failed to copy %s\n", name));
+			tdb_close(tdb_new);
+			unlink(tmp_name);
+			free(tmp_name);
+			if (tdb_transaction_cancel(tdb) != 0 ) goto fail;
+			goto cont;
+		}
+
+		/* copy done, unlock the backup tdb */
+		tdb_unlockall(tdb_new);
+
+#ifdef HAVE_FDATASYNC
+		if (fdatasync(tdb_fd(tdb_new)) != 0)
+#else
+		if (fsync(tdb_fd(tdb_new)) != 0)
+#endif
+		{
+			/* not fatal */
+			DEBUG(0,("TDBTRIM:failed to fsync backup file\n"));
+		}
+
+		/* close the new tdb and re-open read-only */
+		tdb_close(tdb_new);
+		tdb_new = tdb_open_ex(tmp_name,
+				0,
+				tdb_flags|TDB_NOMMAP,
+				O_RDONLY, 0,
+				&lctx, NULL);
+
+		if (!tdb_new) {
+			DEBUG(0,("TDBTRIM:failed to reopen %s\n", tmp_name));
+			unlink(tmp_name);
+			free(tmp_name);
+			if (tdb_transaction_cancel(tdb) != 0 ) goto fail;
+			goto cont;
+		}
+		/* traverse the new tdb to confirm */
+		count2 = tdb_traverse(tdb_new, dummy_fn, NULL);
+		if (count2 != count1) {
+			DEBUG(0,("TDBTRIM:failed to copy %s\n", name));
+			tdb_close(tdb_new);
+			unlink(tmp_name);
+			free(tmp_name);
+			if (tdb_transaction_cancel(tdb) != 0 ) goto fail;
+			goto cont;
+		}
+
+		/* close the new tdb and rename it to original file */
+		tdb_close(tdb_new);
+		tdb_close(tdb);
+		if (rename(tmp_name, name) != 0) {
+			DEBUG(0,("TDBTRIM:failed to copy %s\n", name));
+			free(tmp_name);
+			goto fail; /* unexpected, fail */
+		}
+
+		free(tmp_name);
+
+		if (stat(name, &st) == 0) {
+			DEBUG(0,("TDBTRIM: Size of tdb %s after trim = %u\n",name,(uint32_t)st.st_size));
+		}
+		/* Now reopen the trimmed tdb file! */
+		result->tdb = tdb_open_ex(name, hash_size, tdb_flags,
+				open_flags, mode, &lctx, NULL);
+		if (result->tdb == NULL) {
+			goto fail;
+		}
+	}
+cont:
 	talloc_set_destructor(result, tdb_wrap_private_destructor);
 	DLIST_ADD(tdb_list, result);
 	return result;
diff --git a/lib/tdb_wrap/tdb_wrap.h b/lib/tdb_wrap/tdb_wrap.h
index de7e332..56e801a 100644
--- a/lib/tdb_wrap/tdb_wrap.h
+++ b/lib/tdb_wrap/tdb_wrap.h
@@ -32,6 +32,8 @@
 #include <talloc.h>
 #include <tdb.h>
 
+#define TDB_TRIM_SIZE 8192 /* Trim tdb file so excess free space is freed*/
+
 struct tdb_wrap {
 	struct tdb_context *tdb;
 };
diff --git a/source3/locking/brlock.c b/source3/locking/brlock.c
index aef3ced..32f01d6 100644
--- a/source3/locking/brlock.c
+++ b/source3/locking/brlock.c
@@ -33,6 +33,7 @@
 #include "serverid.h"
 #include "messages.h"
 #include "util_tdb.h"
+#include "tdb_wrap/tdb_wrap.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_LOCKING
@@ -387,6 +388,7 @@ void brl_init(bool read_only)
 			break;
 		}
 
+		if (!read_only) tdb_flags |= TDB_TRIM_SIZE;
 		set_brlock_db(db_open(NULL, db_path,
 				    SMB_OPEN_DATABASE_TDB_HASH_SIZE, tdb_flags,
 				    read_only?O_RDONLY:(O_RDWR|O_CREAT), 0644,
diff --git a/source3/locking/leases_db.c b/source3/locking/leases_db.c
index 0f70071..1082719 100644
--- a/source3/locking/leases_db.c
+++ b/source3/locking/leases_db.c
@@ -26,6 +26,7 @@
 #include "util_tdb.h"
 #include "ndr.h"
 #include "librpc/gen_ndr/ndr_leases_db.h"
+#include "tdb_wrap/tdb_wrap.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_LOCKING
@@ -175,6 +176,7 @@ bool leases_db_init(bool read_only)
 
 		set_leases_db(db_open(NULL, db_path, 0,
 				    TDB_DEFAULT|TDB_VOLATILE|/*TDB_CLEAR_IF_FIRST|*/
+				    (read_only ? 0 : TDB_TRIM_SIZE)|
 				    TDB_INCOMPATIBLE_HASH,
 				    read_only ? O_RDONLY : O_RDWR|O_CREAT, 0644,
 				    DBWRAP_LOCK_ORDER_2, DBWRAP_FLAG_NONE));
diff --git a/source3/locking/share_mode_lock.c b/source3/locking/share_mode_lock.c
index 8736153..7a32e81 100644
--- a/source3/locking/share_mode_lock.c
+++ b/source3/locking/share_mode_lock.c
@@ -49,6 +49,7 @@
 #include "source3/lib/dbwrap/dbwrap_watch.h"
 #include "locking/leases_db.h"
 #include "../lib/util/memcache.h"
+#include "tdb_wrap/tdb_wrap.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_LOCKING
@@ -181,7 +182,8 @@ static bool locking_init_internal(bool read_only)
 		/* handle related entries. If something fails in the middle, we will get rid of the db and move on*/
 		set_lock_db(db_open(NULL, db_path,
 				  SMB_OPEN_DATABASE_TDB_HASH_SIZE,
-				  TDB_DEFAULT|TDB_VOLATILE|/*TDB_CLEAR_IF_FIRST|*/TDB_INCOMPATIBLE_HASH,
+				  TDB_DEFAULT|TDB_VOLATILE|/*TDB_CLEAR_IF_FIRST|*/TDB_INCOMPATIBLE_HASH|
+				  (read_only?0:TDB_TRIM_SIZE),
 				  read_only?O_RDONLY:O_RDWR|O_CREAT, 0644,
 				  DBWRAP_LOCK_ORDER_1, DBWRAP_FLAG_NONE));
 		if (!get_lock_db()) {
diff --git a/source3/smbd/smbXsrv_open.c b/source3/smbd/smbXsrv_open.c
index 9d89f22..ed91f7a 100644
--- a/source3/smbd/smbXsrv_open.c
+++ b/source3/smbd/smbXsrv_open.c
@@ -30,6 +30,7 @@
 #include "lib/util/util_tdb.h"
 #include "librpc/gen_ndr/ndr_smbXsrv.h"
 #include "serverid.h"
+#include "tdb_wrap/tdb_wrap.h"
 
 /* Remove the paranoid malloc checker. */
 #ifdef malloc
@@ -196,7 +197,7 @@ NTSTATUS smbXsrv_open_global_init(void)
 
 		db_ctx = db_open(NULL, global_path,
 				 0, /* hash_size */
-				 TDB_DEFAULT |
+				 TDB_DEFAULT | TDB_TRIM_SIZE |
 				 TDB_INCOMPATIBLE_HASH,
 				 O_RDWR | O_CREAT, 0600,
 				 DBWRAP_LOCK_ORDER_1,
