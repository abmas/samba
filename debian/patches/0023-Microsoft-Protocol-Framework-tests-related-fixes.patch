From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Tue, 21 Jun 2016 21:25:45 -0400
Subject: Microsoft Protocol Framework tests related fixes.

Fix for PersistentHandleReconnectTestCaseSxxx and DurableHandleV2_Reconnect_WithDifferentDurableOwner
If op->global->persistent is set and reconnect comes in without persistent r
Samba was returning NT_STATUS_OBJECT_NAME_NOT_FOUND, instead it should be NT

Changes for remaning durable and persistent, lease/oplock WPTS/MPTF tests.
---
 source3/smbd/smb2_break.c   | 11 +++++++---
 source3/smbd/smb2_create.c  | 50 ++++++++++++++++++++++++++++++++++++---------
 source3/smbd/smb2_ioctl.c   |  8 ++++++++
 source3/smbd/smb2_server.c  |  5 +++++
 source3/smbd/smbXsrv_open.c |  2 +-
 5 files changed, 62 insertions(+), 14 deletions(-)

diff --git a/source3/smbd/smb2_break.c b/source3/smbd/smb2_break.c
index 4c5d62e..62c59c6 100644
--- a/source3/smbd/smb2_break.c
+++ b/source3/smbd/smb2_break.c
@@ -74,13 +74,18 @@ NTSTATUS smbd_smb2_request_process_break(struct smbd_smb2_request *req)
 
 	/* Are we awaiting a break message ? */
 	if (in_fsp->oplock_timeout == NULL) {
-		return smbd_smb2_request_error(
-			req, NT_STATUS_INVALID_OPLOCK_PROTOCOL);
+               if (in_oplock_level == SMB2_OPLOCK_LEVEL_LEASE) {
+                       return smbd_smb2_request_error(
+                               req, NT_STATUS_INVALID_PARAMETER);
+               } else {
+                       return smbd_smb2_request_error(
+                               req, NT_STATUS_INVALID_DEVICE_STATE);
+               }
 	}
 
 	if (in_oplock_level != SMB2_OPLOCK_LEVEL_NONE &&
 	    in_oplock_level != SMB2_OPLOCK_LEVEL_II) {
-		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
+		return smbd_smb2_request_error(req, NT_STATUS_INVALID_OPLOCK_PROTOCOL);
 	}
 
 	subreq = smbd_smb2_oplock_break_send(req, req->sconn->ev_ctx,
diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index d56ef62..e916921 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -773,7 +773,9 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			/*
 			 * durable handle request is processed below.
 			 */
-			durable_requested = true;
+			if ( (requested_oplock_level & SMB2_OPLOCK_LEVEL_BATCH) || rqls ) {
+				durable_requested = true;
+			}
 			/*
 			 * Set the timeout to 16 mins.
 			 *
@@ -824,7 +826,9 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			/*
 			 * durable handle v2 request processed below
 			 */
-			durable_requested = true;
+                        if ( (requested_oplock_level & SMB2_OPLOCK_LEVEL_BATCH) || rqls || persistent_handle ) {
+				durable_requested = true;
+                        }
 			durable_timeout_msec = durable_v2_timeout;
 			if (durable_timeout_msec == 0) {
 				/*
@@ -838,15 +842,23 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 
 		if (dhnc) {
 			persistent_id = BVAL(dhnc->data.data, 0);
-
 			do_durable_reconnect = true;
 		}
 
 		if (dh2c) {
 			const uint8_t *p = dh2c->data.data;
+			uint32_t durable_v2_flags = 0;
 			DATA_BLOB create_guid_blob;
 
 			persistent_id = BVAL(p, 0);
+			durable_v2_flags = IVAL(p,32);
+
+                        DEBUG(3, ("Got durable v2 request with flag  %x and tcon capability %x\n",
+                                           (int)durable_v2_flags, smb2req->tcon->capabilities));
+                        if ((durable_v2_flags & SMB2_DHANDLE_FLAG_PERSISTENT) && (smb2req->tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)) {
+                                DEBUG(3, ("Setting persistent_handle = true\n"));
+				persistent_handle = true;
+			}
 			create_guid_blob = data_blob_const(p + 16, 16);
 
 			status = GUID_from_ndr_blob(&create_guid_blob,
@@ -919,15 +931,25 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 				NDR_PRINT_DEBUG(smb2_lease, lease_ptr);
 			}
 
-			if (!smb2_lease_key_valid(&lease.lease_key)) {
-				lease_ptr = NULL;
+			if ( ! (lease.lease_state & SMB2_LEASE_HANDLE) ) {
+				/* According to MS_SMB2 spec, if lease handle is not requested, do not send
+				 * durable context response.
+				 */
+				durable_requested = false;
 				requested_oplock_level = SMB2_OPLOCK_LEVEL_NONE;
-			}
-
-			if ((smb2req->xconn->protocol < PROTOCOL_SMB3_00) &&
-			    (lease.lease_version != 1)) {
-				DEBUG(10, ("v2 lease key only for SMB3\n"));
 				lease_ptr = NULL;
+			} else {
+
+				if (!smb2_lease_key_valid(&lease.lease_key)) {
+					lease_ptr = NULL;
+					requested_oplock_level = SMB2_OPLOCK_LEVEL_NONE;
+				}
+
+				if ((smb2req->xconn->protocol < PROTOCOL_SMB3_00) &&
+						(lease.lease_version != 1)) {
+					DEBUG(10, ("v2 lease key only for SMB3\n"));
+					lease_ptr = NULL;
+				}
 			}
 		}
 
@@ -970,6 +992,14 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 				return tevent_req_post(req, ev);
 			}
 
+
+                       if ( op->global->persistent && persistent_handle == false ) {
+                                talloc_free(op);
+                                tevent_req_nterror(req,
+                                        NT_STATUS_OBJECT_NAME_NOT_FOUND);
+                                return tevent_req_post(req, ev);
+                        }
+
 			status = SMB_VFS_DURABLE_RECONNECT(smb1req->conn,
 						smb1req,
 						op, /* smbXsrv_open input */
diff --git a/source3/smbd/smb2_ioctl.c b/source3/smbd/smb2_ioctl.c
index 993682f..f93b5fe 100644
--- a/source3/smbd/smb2_ioctl.c
+++ b/source3/smbd/smb2_ioctl.c
@@ -205,6 +205,14 @@ NTSTATUS smbd_smb2_request_process_ioctl(struct smbd_smb2_request *req)
 				NT_STATUS_INVALID_PARAMETER);
 		}
 		break;
+	case FSCTL_LMR_REQ_RESILIENCY:
+		/* As per MS SMB2 spec, the dynamic part should be 8 bytes. If not
+		 * we need to fail with status invalid parameter
+		 */
+		if ( SMBD_SMB2_IN_DYN_LEN(req) < 8 ) {
+			return smbd_smb2_request_error(req,
+                                NT_STATUS_INVALID_PARAMETER);
+		}
 	default:
 		in_fsp = file_fsp_smb2(req, in_file_id_persistent,
 				       in_file_id_volatile);
diff --git a/source3/smbd/smb2_server.c b/source3/smbd/smb2_server.c
index ac922a1..8ba0eea 100644
--- a/source3/smbd/smb2_server.c
+++ b/source3/smbd/smb2_server.c
@@ -1957,6 +1957,7 @@ NTSTATUS smbd_smb2_request_verify_sizes(struct smbd_smb2_request *req,
 	size_t body_size;
 	size_t min_dyn_size = expected_body_size & 0x00000001;
 	int max_idx = req->in.vector_count - SMBD_SMB2_NUM_IOV_PER_REQ;
+	uint32_t in_ctl_code;
 
 	/*
 	 * The following should be checked already.
@@ -1981,6 +1982,10 @@ NTSTATUS smbd_smb2_request_verify_sizes(struct smbd_smb2_request *req,
 
 	switch (opcode) {
 	case SMB2_OP_IOCTL:
+		inbody = SMBD_SMB2_IN_BODY_PTR(req);
+		in_ctl_code = IVAL(inbody, 0x04);
+		if ( in_ctl_code == FSCTL_LMR_REQ_RESILIENCY )
+			DEBUG(0,("SMBD_SMB2_IN_BODY_LEN(req) = %x, SMBD_SMB2_IN_DYN_LEN(req) = %x\n", (uint32_t)SMBD_SMB2_IN_BODY_LEN(req), (uint32_t)SMBD_SMB2_IN_DYN_LEN(req)));
 	case SMB2_OP_GETINFO:
 		min_dyn_size = 0;
 		break;
diff --git a/source3/smbd/smbXsrv_open.c b/source3/smbd/smbXsrv_open.c
index bdcb8ba..bc9e65d 100644
--- a/source3/smbd/smbXsrv_open.c
+++ b/source3/smbd/smbXsrv_open.c
@@ -1331,7 +1331,7 @@ NTSTATUS smb2srv_open_recreate(struct smbXsrv_connection *conn,
 
 	if (!security_token_is_sid(current_token, &op->global->open_owner)) {
 		TALLOC_FREE(op);
-		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
         if (!((op->global->durable) || (op->global->resilient) || (op->global->persistent))) {
