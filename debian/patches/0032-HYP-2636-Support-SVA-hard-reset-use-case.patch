From: Paul Cerqua <paul.cerqua@simplivity.com>
Date: Tue, 19 Jul 2016 20:49:08 +0000
Subject: HYP-2636: Support SVA hard reset use case.

Conflicts:
	source3/smbd/smb2_create.c
---
 source3/librpc/idl/leases_db.idl  |   5 +
 source3/locking/leases_db.c       | 186 +++++++++++++++++++++++---------------
 source3/locking/locking.c         |   6 +-
 source3/locking/share_mode_lock.c |  11 ++-
 source3/smbd/close.c              |  12 +--
 source3/smbd/durable.c            |   6 +-
 source3/smbd/server.c             |   6 +-
 source3/smbd/smb2_break.c         |  30 +++---
 source3/smbd/smb2_create.c        |  18 ++--
 source3/smbd/smbXsrv_open.c       | 108 +++++++++++++++++++++-
 10 files changed, 268 insertions(+), 120 deletions(-)

diff --git a/source3/librpc/idl/leases_db.idl b/source3/librpc/idl/leases_db.idl
index fe2a78d..d727f5e 100644
--- a/source3/librpc/idl/leases_db.idl
+++ b/source3/librpc/idl/leases_db.idl
@@ -20,6 +20,11 @@ interface leases_db
 		[string,charset(UTF8)] char *base_name;
 		[string,charset(UTF8)] char *stream_name;
 		udlong open_persistent_id;
+		/*
+		 * In-memory flag indicating a non-existing pid. We don't want
+		 * to store this share_mode_entry on disk.
+		 */
+		[skip] boolean8 stale;
 	} leases_db_file;
 
 	typedef [public] struct {
diff --git a/source3/locking/leases_db.c b/source3/locking/leases_db.c
index 56431f4..12637fd 100644
--- a/source3/locking/leases_db.c
+++ b/source3/locking/leases_db.c
@@ -33,63 +33,105 @@
 /* the leases database handle */
 static struct db_context *leases_db;
 
+void remove_stale_lease_entries(struct leases_db_value *d)
+{
+	uint32_t i;
+
+	i = 0;
+	while (i < d->num_files) {
+		if (d->files[i].stale) {
+			struct leases_db_file *m = d->files;
+			m[i] = m[d->num_files-1];
+			d->num_files -= 1;
+		} else {
+			i += 1;
+		}
+	}
+}
+
 static int leases_db_traverse_persist_fn(struct db_record *rec, void *_state)
 {
-        uint32_t i;
-        TDB_DATA key,data;
-        TDB_DATA value;
-        DATA_BLOB blob;
-        enum ndr_err_code ndr_err;
-        struct leases_db_value *d;
-        bool found_persistent_open = False;
-        NTSTATUS status;
-
-        key = dbwrap_record_get_key(rec);
-        value = dbwrap_record_get_value(rec);
-
-        DEBUG(1, ("leases_db_traverse_persist_fn: Entering leases_db_traverse_persist_fn\n"));
-
-        /* Ensure this is a key record. */
-        if (key.dsize != sizeof(struct leases_db_key)) {
-		DEBUG(1, ("leases_db_traverse_persist_fn: Record is not a key record - key.dsize is %d\n", key.dsize));
-                return 0;
-        }
-
-        d = talloc(talloc_tos(), struct leases_db_value);
-        if (d == NULL) {
-		DEBUG(1, ("leases_db_traverse_persist_fn: talloc failed\n"));
-                return 0;
-        }
-
-        blob.data = value.dptr;
-        blob.length = value.dsize;
+	uint32_t i;
+	TDB_DATA key,data;
+	TDB_DATA value;
+	DATA_BLOB blob;
+	enum ndr_err_code ndr_err;
+	struct leases_db_value *d;
+	bool found_persistent_open = False;
+	NTSTATUS status;
+
+	key = dbwrap_record_get_key(rec);
+	value = dbwrap_record_get_value(rec);
+
+	DEBUG(1, ("leases_db_traverse_persist_fn: Entering leases_db_traverse_persist_fn\n"));
+
+	/* Ensure this is a key record. */
+	if (key.dsize != sizeof(struct leases_db_key)) {
+	     	DEBUG(1, ("leases_db_traverse_persist_fn: Record is not a key record - key.dsize is %d\n", (int)key.dsize));
+		return 0;
+	}
+
+	d = talloc(talloc_tos(), struct leases_db_value);
+	if (d == NULL) {
+	     	DEBUG(1, ("leases_db_traverse_persist_fn: talloc failed\n"));
+		return 0;
+	}
+
+	blob.data = value.dptr;
+	blob.length = value.dsize;
 
 	ndr_err = ndr_pull_struct_blob_all(
 		&blob, d, d,
 		(ndr_pull_flags_fn_t)ndr_pull_leases_db_value);
-        if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-                DEBUG(1, ("leases_db_traverse_persist_fn: ndr_pull_lease failed\n"));
-                return 0;
-        }
-
-        for (i=0; i<d->num_files; i++) {
-                DEBUG(1, ("leases_db_traverse_persist_fn: Loop iteration %i\n", i));
-                struct leases_db_file *entry = &d->files[i];
-                if ( entry->open_persistent_id != UINT64_MAX && smbXsrv_lookup_persistent_id(entry->open_persistent_id) ) {
-                        found_persistent_open = True;
-                        DEBUG(1, ("leases_db_traverse_persist_fn: Found a persistent open, retaining record for id %ld\n", entry->open_persistent_id));
-                }
-        }
-
-        if ( !found_persistent_open ) {
-                DEBUG(1, ("leases_db_traverse_persist_fn: Removing record from leases.tdb\n"));
-                dbwrap_record_delete(rec);
-        }
-
-        TALLOC_FREE(d);
-        DEBUG(1, ("leases_db_traverse_persist_fn: Leaving leases_db_traverse_persist_fn\n"));
-
-        return 0;
+	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		DEBUG(1, ("leases_db_traverse_persist_fn: ndr_pull_lease failed\n"));
+		return 0;
+	}
+
+	for (i=0; i<d->num_files; i++) {
+		DEBUG(1, ("leases_db_traverse_persist_fn: Loop iteration %i\n", i));
+		struct leases_db_file *entry = &d->files[i];
+		if ( entry->open_persistent_id != UINT64_MAX && smbXsrv_lookup_persistent_id(entry->open_persistent_id) ) {
+			entry->stale = false; /* [skip] in idl */
+			found_persistent_open = True;
+			DEBUG(1, ("leases_db_traverse_persist_fn: Found a persistent open, retaining record for id %ld\n", entry->open_persistent_id));
+		} else {
+			entry->stale = true; /* [skip] in idl */
+		}
+	}
+
+	if ( !found_persistent_open ) {
+		DEBUG(1, ("leases_db_traverse_persist_fn: Removing record from leases.tdb\n"));
+		dbwrap_record_delete(rec);
+	} else {
+		remove_stale_lease_entries(d);
+
+		if (d->num_files == 0) {
+			DEBUG(10, ("No used lease found\n"));
+			data = make_tdb_data(NULL, 0);
+		} else {
+			ndr_err = ndr_push_struct_blob(
+				&blob, d, d, (ndr_push_flags_fn_t)ndr_push_leases_db_value);
+			if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+				smb_panic("ndr_push_leases_db failed");
+				return 0;
+			}
+
+			data = make_tdb_data(blob.data, blob.length);
+		}
+
+		if ( data.dptr != NULL ) {
+			status = dbwrap_record_store(rec, data, TDB_REPLACE);
+			if (!NT_STATUS_IS_OK(status)) {
+				DEBUG(1, ("leases_db_traverse_persist_fn: store returned %s\n", nt_errstr(status)));
+			}
+		}
+	}
+
+	TALLOC_FREE(d);
+	DEBUG(1, ("leases_db_traverse_persist_fn: Leaving leases_db_traverse_persist_fn\n"));
+
+	return 0;
 }
 
 bool leases_db_init(bool read_only)
@@ -117,27 +159,27 @@ bool leases_db_init(bool read_only)
 		return false;
 	}
 
-        if ( read_only == false ) {
-                /* traverse the db and only get rid of entries not belonging to a persistent open */
-                status = dbwrap_traverse_read(leases_db, leases_db_traverse_persist_fn, NULL, NULL);
-
-                if ( ! NT_STATUS_IS_OK(status) ) {
-                        TALLOC_FREE(leases_db);
-                        /* Cleanup and move on */
-                        DEBUG(0,("ERROR: Failed to recover persistent handle related lease entries. Cleanup and proceed.\n"));
-                        leases_db = db_open(NULL, db_path, 0,
-                                TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
-                                read_only?O_RDONLY:O_RDWR|O_CREAT, 0644,
-                                DBWRAP_LOCK_ORDER_2, DBWRAP_FLAG_NONE);
-                        if (!leases_db) {
-                                DEBUG(0,("ERROR: Failed to initialise lease database\n"));
-                                TALLOC_FREE(db_path);
-                                return False;
-                        }
-                } else {
-                        TALLOC_FREE(db_path);
-                }
-        }
+	if ( read_only == false ) {
+		/* traverse the db and only get rid of entries not belonging to a persistent open */
+		status = dbwrap_traverse(leases_db, leases_db_traverse_persist_fn, NULL, NULL);
+
+		if ( ! NT_STATUS_IS_OK(status) ) {
+			TALLOC_FREE(leases_db);
+			/* Cleanup and move on */
+			DEBUG(0,("ERROR: Failed to recover persistent handle related lease entries. Cleanup and proceed.\n"));
+			leases_db = db_open(NULL, db_path, 0,
+				TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+				read_only?O_RDONLY:O_RDWR|O_CREAT, 0644,
+				DBWRAP_LOCK_ORDER_2, DBWRAP_FLAG_NONE);
+			if (!leases_db) {
+				DEBUG(0,("ERROR: Failed to initialise lease database\n"));
+				TALLOC_FREE(db_path);
+				return False;
+			}
+		} else {
+			TALLOC_FREE(db_path);
+		}
+	}
 
 	return true;
 }
diff --git a/source3/locking/locking.c b/source3/locking/locking.c
index cee73b9..603a5d4 100644
--- a/source3/locking/locking.c
+++ b/source3/locking/locking.c
@@ -851,11 +851,7 @@ bool set_share_mode(struct share_mode_lock *lck, struct files_struct *fsp,
 	/* For persistent opens, record the persistent id as we will need it when reconnecting after a crash*/
 	/* Note that setting it here does not work for resilient handle for example, which can be made resilient */
 	/* using an ioctl. Persistent handle has to be requested at create time, so setting it here works. */
-	if ( 1 == fsp->op->global->persistent ) {
-		e->open_persistent_id = fsp->op->global->open_persistent_id;
-	} else {
-		e->open_persistent_id = UINT64_MAX;
-	}
+	e->open_persistent_id = fsp->op->global->open_persistent_id;
 	e->uid = (uint32_t)uid;
 	e->flags = (fsp->posix_flags & FSP_POSIX_FLAGS_OPEN) ?
 		SHARE_MODE_FLAG_POSIX_OPEN : 0;
diff --git a/source3/locking/share_mode_lock.c b/source3/locking/share_mode_lock.c
index 52305b8..770c99b 100644
--- a/source3/locking/share_mode_lock.c
+++ b/source3/locking/share_mode_lock.c
@@ -103,7 +103,12 @@ static int sml_traverse_persist_fn(struct db_record *rec, void *_state)
                 struct share_mode_entry *entry = &d->share_modes[i];
 		if ( entry->open_persistent_id != UINT64_MAX && smbXsrv_lookup_persistent_id(entry->open_persistent_id) ) {
                 	entry->stale = false; /* [skip] in idl */
-                	entry->lease = &d->leases[entry->lease_idx];
+			if ( (entry->op_type == LEASE_OPLOCK) &&
+				(entry->lease_idx < d->num_leases) ) {
+				entry->lease = &d->leases[entry->lease_idx];
+			} else {
+				entry->lease = NULL;
+			}
 			found_persistent_open = True;
 			server_id_set_disconnected(&entry->pid);
 			entry->share_file_id = entry->open_persistent_id;
@@ -119,7 +124,7 @@ static int sml_traverse_persist_fn(struct db_record *rec, void *_state)
 	} else {
 		data = unparse_share_modes(d);
 		if ( data.dptr != NULL ) {
-			status = dbwrap_record_store(d->record, data, TDB_REPLACE);
+			status = dbwrap_record_store(rec, data, TDB_REPLACE);
 			if (!NT_STATUS_IS_OK(status)) {
 				DEBUG(1, ("sml_traverse_persist_fn: store returned %s\n", nt_errstr(status)));
 			}
@@ -167,7 +172,7 @@ static bool locking_init_internal(bool read_only)
 
 	if ( read_only == false ) {
 		/* Ashok: traverse the db and only get rid of entries not belonging to a persistent open */
-		status = dbwrap_traverse_read(lock_db, sml_traverse_persist_fn, NULL, NULL);
+		status = dbwrap_traverse(lock_db, sml_traverse_persist_fn, NULL, NULL);
 
 		if ( ! NT_STATUS_IS_OK(status) ) {
 			TALLOC_FREE(lock_db);
diff --git a/source3/smbd/close.c b/source3/smbd/close.c
index 634b046..6a67808 100644
--- a/source3/smbd/close.c
+++ b/source3/smbd/close.c
@@ -667,13 +667,11 @@ static NTSTATUS close_normal_file(struct smb_request *req, files_struct *fsp,
 	if (close_type != SHUTDOWN_CLOSE) {
 		is_durable = false;
 	}
-
-#ifdef STRICT_RESILIENT_CHECKING
-        if ( fsp->op->global->resilient && !lp_smb2_leases() ) {
-               is_durable = false;
-        }
-#endif
-
+/*
+	if ( fsp->op->global->resilient && !lp_smb2_leases() ) {
+		is_durable = false;
+	}
+*/
 	if (is_durable) {
 		DATA_BLOB new_cookie = data_blob_null;
 
diff --git a/source3/smbd/durable.c b/source3/smbd/durable.c
index 868e563..3be3734 100644
--- a/source3/smbd/durable.c
+++ b/source3/smbd/durable.c
@@ -93,7 +93,11 @@ NTSTATUS vfs_default_durable_cookie(struct files_struct *fsp,
 	}
 
 	ZERO_STRUCT(cookie);
-	cookie.allow_reconnect = false;
+	if (fsp->op && fsp->op->global && fsp->op->global->persistent) {
+		cookie.allow_reconnect = true;
+	} else {
+		cookie.allow_reconnect = false;
+	}
 	cookie.id = fsp->file_id;
 	cookie.servicepath = conn->connectpath;
 	cookie.base_name = fsp->fsp_name->base_name;
diff --git a/source3/smbd/server.c b/source3/smbd/server.c
index 5d17137..cc1e14e 100644
--- a/source3/smbd/server.c
+++ b/source3/smbd/server.c
@@ -1639,13 +1639,13 @@ extern void build_options(bool screen);
 		exit_daemon("Samba cannot init global open", map_errno_from_nt_status(status));
 	}
 
-	if (!locking_init())
-		exit_daemon("Samba cannot init locking", EACCES);
-
 	if (!leases_db_init(false)) {
 		exit_daemon("Samba cannot init leases", EACCES);
 	}
 
+	if (!locking_init())
+		exit_daemon("Samba cannot init locking", EACCES);
+
 	/* This MUST be done before start_epmd() because otherwise
 	 * start_epmd() forks and races against dcesrv_ep_setup() to
 	 * call directory_create_or_exist() */
diff --git a/source3/smbd/smb2_break.c b/source3/smbd/smb2_break.c
index 607217e..a88d693 100644
--- a/source3/smbd/smb2_break.c
+++ b/source3/smbd/smb2_break.c
@@ -74,21 +74,21 @@ NTSTATUS smbd_smb2_request_process_break(struct smbd_smb2_request *req)
 
 	/* Are we awaiting a break message ? */
 	if (in_fsp->oplock_timeout == NULL) {
-               if (in_oplock_level == SMB2_OPLOCK_LEVEL_LEASE) {
-                       return smbd_smb2_request_error(
-                               req, NT_STATUS_INVALID_PARAMETER);
-               } else if ( (in_fsp->oplock_type == EXCLUSIVE_OPLOCK || in_fsp->oplock_type == BATCH_OPLOCK) &&
-                          (in_oplock_level != SMB2_OPLOCK_LEVEL_II && in_oplock_level != SMB2_OPLOCK_LEVEL_NONE ) ) {
-                       return smbd_smb2_request_error(
-                               req, NT_STATUS_INVALID_OPLOCK_PROTOCOL);
-               } else if ( (in_fsp->oplock_type == LEVEL_II_OPLOCK ) &&
-                          (in_oplock_level != NO_OPLOCK) ) {
-                       return smbd_smb2_request_error(
-                               req, NT_STATUS_INVALID_OPLOCK_PROTOCOL);
-               } else if ( in_oplock_level == LEVEL_II_OPLOCK || in_oplock_level == NO_OPLOCK ) {
-                       return smbd_smb2_request_error(
-                               req, NT_STATUS_INVALID_DEVICE_STATE);
-               }
+		if (in_oplock_level == SMB2_OPLOCK_LEVEL_LEASE) {
+			return smbd_smb2_request_error(
+				req, NT_STATUS_INVALID_PARAMETER);
+		} else if ( (in_fsp->oplock_type == EXCLUSIVE_OPLOCK || in_fsp->oplock_type == BATCH_OPLOCK) &&
+			(in_oplock_level != SMB2_OPLOCK_LEVEL_II && in_oplock_level != SMB2_OPLOCK_LEVEL_NONE ) ) {
+			return smbd_smb2_request_error(
+				req, NT_STATUS_INVALID_OPLOCK_PROTOCOL);
+		} else if ( (in_fsp->oplock_type == LEVEL_II_OPLOCK ) &&
+			(in_oplock_level != NO_OPLOCK) ) {
+			return smbd_smb2_request_error(
+				req, NT_STATUS_INVALID_OPLOCK_PROTOCOL);
+		} else if ( in_oplock_level == LEVEL_II_OPLOCK || in_oplock_level == NO_OPLOCK ) {
+			return smbd_smb2_request_error(
+				req, NT_STATUS_INVALID_DEVICE_STATE);
+		}
 	}
 
 	subreq = smbd_smb2_oplock_break_send(req, req->sconn->ev_ctx,
diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index 499efd1..bfdccc9 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -987,8 +987,8 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 					   (int)lease_len));
 				NDR_PRINT_DEBUG(smb2_lease, lease_ptr);
 			}
-                        if ( ( durable_requested || do_durable_reconnect ) &&
-                             (! (lease.lease_state & SMB2_LEASE_HANDLE) ) ) {
+			if ( ( durable_requested || do_durable_reconnect ) &&
+				(! (lease.lease_state & SMB2_LEASE_HANDLE) ) ) {
 				/* According to MS_SMB2 spec, 
 				 * 1) if durable is requested and
 				 * 2) lease context is provided/requested and
@@ -1276,6 +1276,13 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			}
 		}
 
+                if (persistent_handle) {
+                        op->global->durable = true;
+                        op->global->persistent = true;
+                        op->global->durable_timeout_msec = durable_timeout_msec;
+                        update_open = true;
+                }
+
 		if (!replay_operation && durable_requested )
                 /*
                  *  Removed this check:
@@ -1309,13 +1316,6 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			op->global->durable_timeout_msec = durable_timeout_msec;
 		}
 
-                if (persistent_handle) {
-                        op->global->durable = true;
-                        op->global->persistent = true;
-                        op->global->durable_timeout_msec = durable_timeout_msec;
-                        update_open = true;
-                }
-
 		if (update_open) {
 			op->global->create_guid = _create_guid;
 			if (need_replay_cache) {
diff --git a/source3/smbd/smbXsrv_open.c b/source3/smbd/smbXsrv_open.c
index 9f7add5..da364eb 100644
--- a/source3/smbd/smbXsrv_open.c
+++ b/source3/smbd/smbXsrv_open.c
@@ -50,6 +50,14 @@ struct smbXsrv_open_table {
 	} global;
 };
 
+struct db_record {
+        struct db_context *db;
+        TDB_DATA key, value;
+        NTSTATUS (*store)(struct db_record *rec, TDB_DATA data, int flag);
+        NTSTATUS (*delete_rec)(struct db_record *rec);
+        void *private_data;
+};
+
 static struct db_context *smbXsrv_open_global_db_ctx = NULL;
 
 struct smbXsrv_open_persistent_id *smbXsrv_open_global_persistent_ids = NULL;
@@ -58,6 +66,8 @@ static NTSTATUS smbXsrv_open_global_parse_record(TALLOC_CTX *mem_ctx,
 						 struct db_record *rec,
 						 struct smbXsrv_open_global0 **global);
 
+NTSTATUS smbXsrv_open_disconnect(struct smbXsrv_open_global0 *global, struct db_context *db_ctx, NTTIME now);
+
 static int smbXsrv_open_global_traverse_persist_fn(struct db_record *rec, void *data)
 {
         /**
@@ -68,6 +78,9 @@ static int smbXsrv_open_global_traverse_persist_fn(struct db_record *rec, void *
 
 	struct smbXsrv_open_global0 *global = NULL;
 	NTSTATUS status;
+        struct db_record *result;
+	TDB_DATA key;
+	TDB_DATA val;
 
 	status = smbXsrv_open_global_parse_record(talloc_tos(), rec, &global);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -75,7 +88,17 @@ static int smbXsrv_open_global_traverse_persist_fn(struct db_record *rec, void *
 		return -1;
 	}
 
-	global->db_rec = rec;
+	key = dbwrap_record_get_key(rec);
+
+	val = dbwrap_record_get_value(rec);
+
+        result = (struct db_record *)talloc_size(
+		global,
+                sizeof(struct db_record) + key.dsize + val.dsize);
+
+	global->db_rec = result;
+	memcpy(global->db_rec, rec, sizeof(struct db_record) + key.dsize + val.dsize);
+
         if (global->persistent == 1) {
                 struct smbXsrv_open_persistent_id *persistent_id_element = malloc(sizeof(struct smbXsrv_open_persistent_id));
                 struct smbXsrv_open_persistent_id *last_element = smbXsrv_open_global_persistent_ids;
@@ -91,10 +114,11 @@ static int smbXsrv_open_global_traverse_persist_fn(struct db_record *rec, void *
                 } else {
                        smbXsrv_open_global_persistent_ids = persistent_id_element;
                 }
+		smbXsrv_open_disconnect(global, smbXsrv_open_global_db_ctx, 0);
         } else {
                 status = dbwrap_record_delete(rec);
 	        if (!NT_STATUS_IS_OK(status)) {
-	                DEBUG(1, ("error when deleting non-persistent record\n"));
+	                DEBUG(1, ("smbXsrv_open_global_traverse_persist_fn: error when deleting non-persistent record in traverse function\n"));
          	}
         }
 
@@ -168,9 +192,9 @@ NTSTATUS smbXsrv_open_global_init(void)
 	}
 
 	smbXsrv_open_global_db_ctx = db_ctx;
-	status = dbwrap_traverse_read(smbXsrv_open_global_db_ctx,
-				      smbXsrv_open_global_traverse_persist_fn,
-				      NULL, NULL);
+	status = dbwrap_traverse(smbXsrv_open_global_db_ctx,
+				 smbXsrv_open_global_traverse_persist_fn,
+				 NULL, NULL);
 
 	return NT_STATUS_OK;
 }
@@ -1150,6 +1174,80 @@ NTSTATUS smbXsrv_open_update(struct smbXsrv_open *op)
 	return NT_STATUS_OK;
 }
 
+NTSTATUS smbXsrv_open_disconnect(struct smbXsrv_open_global0 *global, struct db_context *db_ctx, NTTIME now)
+{
+	struct db_record *global_rec = NULL;
+	NTSTATUS status;
+	NTSTATUS error = NT_STATUS_OK;
+
+	global->disconnect_time = now;
+	server_id_set_disconnected(&global->server_id);
+
+	global_rec = global->db_rec;
+	global->db_rec = NULL;
+	if (global_rec == NULL) {
+		uint8_t key_buf[SMBXSRV_OPEN_GLOBAL_TDB_KEY_SIZE];
+		TDB_DATA key;
+
+		key = smbXsrv_open_global_id_to_key(
+						global->open_global_id,
+						key_buf);
+
+		global_rec = dbwrap_fetch_locked(db_ctx,
+						 global, key);
+		if (global_rec == NULL) {
+			DEBUG(0, ("smbXsrv_open_disconnect(0x%08x): "
+				  "Failed to lock global key '%s'\n",
+				  global->open_global_id,
+				  hex_encode_talloc(global_rec, key.dptr,
+						    key.dsize)));
+			error = NT_STATUS_INTERNAL_ERROR;
+		}
+	}
+
+        if (global_rec != NULL && ((global->durable) || (global->resilient) || (global->persistent))) {
+		/*
+		 * If it is a durable open we need to update the global part
+		 * instead of deleting it
+		 */
+		global->db_rec = global_rec;
+		status = smbXsrv_open_global_store(global);
+		if (NT_STATUS_IS_OK(status)) {
+			/*
+			 * smbXsrv_open_global_store does the free
+			 * of op->global->db_rec
+			 */
+			global_rec = NULL;
+		}
+		if (!NT_STATUS_IS_OK(status)) {
+			DEBUG(0,("smbXsrv_open_disconnect(0x%08x)"
+				 "smbXsrv_open_global_store() failed - %s\n",
+				 global->open_global_id,
+				 nt_errstr(status)));
+			error = status;
+		}
+	}
+
+	if (global_rec != NULL) {
+		status = dbwrap_record_delete(global_rec);
+		if (!NT_STATUS_IS_OK(status)) {
+			TDB_DATA key = dbwrap_record_get_key(global_rec);
+
+			DEBUG(0, ("smbXsrv_open_disconnect(0x%08x): "
+				  "failed to delete global key '%s': %s\n",
+				  global->open_global_id,
+				  hex_encode_talloc(global_rec, key.dptr,
+						    key.dsize),
+				  nt_errstr(status)));
+			error = status;
+		}
+	}
+
+	TALLOC_FREE(global_rec);
+
+	return error;
+}
+
 NTSTATUS smbXsrv_open_close(struct smbXsrv_open *op, NTTIME now)
 {
 	struct smbXsrv_open_table *table;
