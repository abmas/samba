From: Paul Cerqua <paul.cerqua@simplivity.com>
Date: Mon, 7 May 2018 14:24:56 -0400
Subject: HYP-6469: Split brain changes

---
 source3/smbd/process.c         |   5 +-
 source3/smbd/proto.h           |   3 +-
 source3/smbd/server.c          |   5 +-
 source3/smbd/server_reload.c   | 108 +++++++++++++++++++++++++++++++++++++++--
 source3/smbd/smbXsrv_session.c |  33 +++++++++++++
 5 files changed, 147 insertions(+), 7 deletions(-)

diff --git a/source3/smbd/process.c b/source3/smbd/process.c
index ebfa3b2..c0e3520 100644
--- a/source3/smbd/process.c
+++ b/source3/smbd/process.c
@@ -990,7 +990,8 @@ void smbd_setup_sig_term_handler(struct smbd_server_connection *sconn)
 	}
 }
 
-extern void closedbs_not_owned(struct smbd_server_connection *);
+extern void closedbs_not_owned(struct smbd_server_connection *,
+				  struct smbd_parent_context *);
 
 static void smbd_sig_hup_handler(struct tevent_context *ev,
 				  struct tevent_signal *se,
@@ -1007,7 +1008,7 @@ static void smbd_sig_hup_handler(struct tevent_context *ev,
 	DEBUG(1,("Reloading services after SIGHUP\n"));
 
 	reload_services(sconn, conn_snum_used, false);
-	closedbs_not_owned(sconn);
+	closedbs_not_owned(sconn, NULL);
 }
 
 void smbd_setup_sig_hup_handler(struct smbd_server_connection *sconn)
diff --git a/source3/smbd/proto.h b/source3/smbd/proto.h
index a44d4d3..d5edb87 100644
--- a/source3/smbd/proto.h
+++ b/source3/smbd/proto.h
@@ -1015,7 +1015,8 @@ void delete_and_reload_printers(struct tevent_context *ev,
 bool reload_services(struct smbd_server_connection *sconn,
 		     bool (*snumused) (struct smbd_server_connection *, int),
 		     bool test);
-void closedbs_not_owned(struct smbd_server_connection *);
+//void closedbs_not_owned(struct smbd_server_connection *,
+//                        struct smbd_parent_context *);
 
 /* The following definitions come from smbd/server_exit.c  */
 
diff --git a/source3/smbd/server.c b/source3/smbd/server.c
index 108400b..5251166 100644
--- a/source3/smbd/server.c
+++ b/source3/smbd/server.c
@@ -34,6 +34,7 @@
 #include "libcli/auth/schannel.h"
 #include "secrets.h"
 #include "../lib/util/memcache.h"
+#include "../lib/tsocket/tsocket.h"
 #include "ctdbd_conn.h"
 #include "util_cluster.h"
 #include "printing/queue_process.h"
@@ -1276,6 +1277,7 @@ static void smbd_parent_sig_hup_handler(struct tevent_context *ev,
 		talloc_get_type_abort(private_data,
 		struct smbd_parent_context);
         int no_svtfs = 0, yes_svtfs = 0;
+        struct smbd_open_socket *socket, *next_socket;
 
 	DEBUG(3,("smbd_parent_sighup_handler: Got message saying smb.conf was "
 		  "updated. Reloading. svtfs index = %d\n", svtfs_get_lockdir_index()));
@@ -1289,7 +1291,8 @@ static void smbd_parent_sig_hup_handler(struct tevent_context *ev,
 
 	DEBUG(1,("parent: Reloading services after SIGHUP\n"));
 	reload_services(NULL, NULL, false);
-        closedbs_not_owned(NULL);
+        closedbs_not_owned(NULL, parent);
+
         if (svtfs_lockdir_path[svtfs_get_lockdir_index()] != NULL && strstr(svtfs_lockdir_path[svtfs_get_lockdir_index()],"svtfs"))
         {
                /* new lockdir path within svtfs specified */
diff --git a/source3/smbd/server_reload.c b/source3/smbd/server_reload.c
index 516e18d..d10b51f 100644
--- a/source3/smbd/server_reload.c
+++ b/source3/smbd/server_reload.c
@@ -36,6 +36,39 @@
 #include "lib/param/loadparm.h"
 #include "../lib/tsocket/tsocket.h"
 
+struct smbd_open_socket;
+struct smbd_child_pid;
+
+struct smbd_parent_context {
+        bool interactive;
+
+        struct tevent_context *ev_ctx;
+        struct messaging_context *msg_ctx;
+
+        /* the list of listening sockets */
+        struct smbd_open_socket *sockets;
+
+        /* the list of current child processes */
+        struct smbd_child_pid *children;
+        size_t num_children;
+
+        struct server_id cleanupd;
+
+        struct tevent_timer *cleanup_te;
+};
+
+struct smbd_open_socket {
+        struct smbd_open_socket *prev, *next;
+        struct smbd_parent_context *parent;
+        int fd;
+        struct tevent_fd *fde;
+};
+
+struct smbd_child_pid {
+        struct smbd_child_pid *prev, *next;
+        pid_t pid;
+};
+
 /*
  * The persistent pcap cache is populated by the background print process. Per
  * client smbds should only reload their printer share inventories if this
@@ -186,11 +219,17 @@ extern struct db_context * brlock_db[], * leases_db[], * lock_db[], * smbXsrv_cl
 extern char * svtfs_storage_ip[];
 extern char * svtfs_lockdir_path[];
 
-void closedbs_not_owned(struct smbd_server_connection * sconn)
+void close_socket(char *storage_ip_address, struct smbd_parent_context *parent);
+
+void closedbs_not_owned(struct smbd_server_connection * sconn,
+                        struct smbd_parent_context * parent)
 {
         int indexArray[MAX_LOCKDIRS], i, j;
         char * storip = NULL;
+
+        DEBUG(1, ("closedbs_not_owned: entering\n"));
         if (sconn) {
+                DEBUG(1, ("closedbs_not_owned: we have an sconn\n"));
                 if (tsocket_address_is_inet(sconn->local_address, "ip")) {
                         storip = tsocket_address_inet_addr_string( sconn->local_address, talloc_tos());
                         DEBUG(1, ("closedbs_not_owned: storage_ip for this connection = %s\n", storip));
@@ -203,10 +242,13 @@ void closedbs_not_owned(struct smbd_server_connection * sconn)
         {
                 j = indexArray[i];
                 if (j == -1) continue;
+                DEBUG(1, ("closedbs_not_owned: in loop, working on index %s\n", svtfs_storage_ip[j]));
                 if (storip) {
                         DEBUG(1, ("closedbs_not_owned: storage_ip for this connection = %s, storeip for index = %s\n", storip,svtfs_storage_ip[j]));
                         /*exit_server_cleanly("svtfs: Exiting because the storage IP is gone!");*/
-                        if (strcmp(svtfs_storage_ip[j],storip) == 0) exit(0);
+                        if (strcmp(svtfs_storage_ip[j],storip) == 0) {
+                             exit(0);
+                        }
                 }
                 closedb_for_index (brlock_db, j);
                 closedb_for_index (leases_db, j);
@@ -220,6 +262,66 @@ void closedbs_not_owned(struct smbd_server_connection * sconn)
                         talloc_free(svtfs_lockdir_path[j]);
                         svtfs_lockdir_path[j]=NULL;
                 }
-                if (svtfs_storage_ip[j] != NULL) {talloc_free(svtfs_storage_ip[j]); svtfs_storage_ip[j]=NULL;}
+                if (svtfs_storage_ip[j] != NULL) {
+                        DEBUG(1, ("closedbs_not_owned: in loop, removing %s\n", svtfs_storage_ip[j]));
+                        if (parent) {
+                              DEBUG(1, ("closedbs_not_owned: in loop, closing socket %s\n", svtfs_storage_ip[j]));
+                              close_socket(svtfs_storage_ip[j], parent);
+                        }
+                        talloc_free(svtfs_storage_ip[j]);
+                        svtfs_storage_ip[j]=NULL;
+                }
         }
 }
+
+void close_socket(char *storage_ip_address, struct smbd_parent_context *parent)
+{
+        struct tsocket_address *local_address = NULL;
+        struct sockaddr_storage ss_srv;
+        void *sp_srv = (void *)&ss_srv;
+        struct sockaddr *sa_srv = (struct sockaddr *)sp_srv;
+        struct smbd_open_socket *socket, *next_socket;
+        socklen_t sa_socklen = sizeof(ss_srv);
+        int ret;
+
+        /*
+         *  Find the socket associated with this storage IP address
+         */
+        DEBUG(1, ("close_socket: closing socket %s\n", storage_ip_address));
+        socket = parent->sockets;
+
+        while ( socket != NULL ) {
+
+                next_socket = socket->next;
+
+                ret = getsockname(socket->fd, sa_srv, &sa_socklen);
+                if (ret != 0) {
+                        int saved_errno = errno;
+                        int level = (errno == ENOTCONN)?2:0;
+                        DEBUG(level,("getsockname() failed - %s\n",
+                              strerror(saved_errno)));
+                        return;
+                }
+                ret = tsocket_address_bsd_from_sockaddr(parent,
+                                                sa_srv, sa_socklen,
+                                                &local_address);
+                if (ret != 0) {
+                        int saved_errno = errno;
+                        DEBUG(0,("%s: tsocket_address_bsd_from_sockaddr remote failed - %s\n",
+                                __location__, strerror(saved_errno)));
+                        return;
+                }
+
+                DEBUG(1, ("close_socket: compare to %s\n", tsocket_address_string(local_address, talloc_tos())));
+                if ( strcmp(storage_ip_address, tsocket_address_inet_addr_string(local_address, talloc_tos())) == 0 ) {
+                        DEBUG(1, ("close_socket: closing fd for address %s\n", storage_ip_address));
+                        talloc_free(socket->fde);
+                        DLIST_REMOVE(parent->sockets, socket);
+                        close(socket->fd);
+                        talloc_free(socket);
+                }
+
+                socket = next_socket;
+        }
+}
+
diff --git a/source3/smbd/smbXsrv_session.c b/source3/smbd/smbXsrv_session.c
index 9a74bb0..7b30155 100644
--- a/source3/smbd/smbXsrv_session.c
+++ b/source3/smbd/smbXsrv_session.c
@@ -1069,6 +1069,8 @@ static void smb2srv_session_close_previous_check(struct tevent_req *req)
 	struct tevent_req *subreq = NULL;
 	NTSTATUS status;
 	bool is_free = false;
+	int index;
+	int MAX_PROCESS_STOP_TIMEOUT = 6;
 
 	smbXsrv_session_global_verify_record(state->db_rec,
 					     &is_free,
@@ -1137,6 +1139,37 @@ static void smb2srv_session_close_previous_check(struct tevent_req *req)
 		return;
 	}
 
+	/*
+	 * Keep checking to see if the old process has gone away.  If it's
+	 * still there after a maximum number of iterations, then try the
+	 * brute force SIGKILL.  In either case, log whether or not the
+	 * old process has been removed.
+	*/
+
+	if (global->channels[0].server_id.pid != getpid()) {
+		for (index = 0; index < MAX_PROCESS_STOP_TIMEOUT; index++) {
+			if (!serverid_exists(&(global->channels[0].server_id))) {
+				break;
+			}
+
+			if (index == (MAX_PROCESS_STOP_TIMEOUT - 1)) {
+				kill(global->channels[0].server_id.pid, SIGKILL);
+			}
+
+			sleep(1);
+		}
+
+		if (!serverid_exists(&(global->channels[0].server_id))) {
+			DEBUG(1,("smb2srv_session_close_previous_check: "
+				"previous smbd process with PID %i successfully stopped\n",
+				(int) global->channels[0].server_id.pid));
+		} else {
+			DEBUG(1,("smb2srv_session_close_previous_check: "
+				"previous smbd process with PID %i NOT successfully stopped; continuing...\n",
+				(int) global->channels[0].server_id.pid));
+		}
+	}
+
 	TALLOC_FREE(global);
 	return;
 }
