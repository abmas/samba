From: root <root@OC-ip20-44.pcerq.hyperv.local>
Date: Wed, 20 Jul 2016 15:33:36 +0000
Subject: HYP-2636 - Code cleanup for surviving SVA hard restart

---
 source3/librpc/idl/leases_db.idl  | 4 ++--
 source3/locking/brlock.c          | 1 +
 source3/locking/leases_db.c       | 6 ++++--
 source3/locking/share_mode_lock.c | 1 +
 source3/smbd/close.c              | 6 ++++--
 5 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/source3/librpc/idl/leases_db.idl b/source3/librpc/idl/leases_db.idl
index d727f5e..9dffa21 100644
--- a/source3/librpc/idl/leases_db.idl
+++ b/source3/librpc/idl/leases_db.idl
@@ -21,8 +21,8 @@ interface leases_db
 		[string,charset(UTF8)] char *stream_name;
 		udlong open_persistent_id;
 		/*
-		 * In-memory flag indicating a non-existing pid. We don't want
-		 * to store this share_mode_entry on disk.
+		 * In-memory flag indicating a non-existing id. We don't want
+		 * to store this leases_db_file on disk.
 		 */
 		[skip] boolean8 stale;
 	} leases_db_file;
diff --git a/source3/locking/brlock.c b/source3/locking/brlock.c
index d383f93..f051cfd 100644
--- a/source3/locking/brlock.c
+++ b/source3/locking/brlock.c
@@ -1887,6 +1887,7 @@ static int brl_traverse_persist_fn(struct db_record *rec, void *state)
 		status = dbwrap_record_delete(rec);
 		if (!NT_STATUS_IS_OK(status)) {
                 	DEBUG(1, ("brl_traverse_persist_fn: Error deleting record for persistent id %lu\n", locks->context.smblctx));
+			TALLOC_FREE(locks);
                 	return 0; /*best effort, try to keep going*/
         	}
                 DEBUG(1, ("brl_traverse_persist_fn: Deleted brl lock record for persistent id %lu\n", locks->context.smblctx));
diff --git a/source3/locking/leases_db.c b/source3/locking/leases_db.c
index 12637fd..04020ee 100644
--- a/source3/locking/leases_db.c
+++ b/source3/locking/leases_db.c
@@ -67,13 +67,13 @@ static int leases_db_traverse_persist_fn(struct db_record *rec, void *_state)
 
 	/* Ensure this is a key record. */
 	if (key.dsize != sizeof(struct leases_db_key)) {
-	     	DEBUG(1, ("leases_db_traverse_persist_fn: Record is not a key record - key.dsize is %d\n", (int)key.dsize));
+		DEBUG(1, ("leases_db_traverse_persist_fn: Record is not a key record - key.dsize is %d\n", (int)key.dsize));
 		return 0;
 	}
 
 	d = talloc(talloc_tos(), struct leases_db_value);
 	if (d == NULL) {
-	     	DEBUG(1, ("leases_db_traverse_persist_fn: talloc failed\n"));
+		DEBUG(1, ("leases_db_traverse_persist_fn: talloc failed\n"));
 		return 0;
 	}
 
@@ -85,6 +85,7 @@ static int leases_db_traverse_persist_fn(struct db_record *rec, void *_state)
 		(ndr_pull_flags_fn_t)ndr_pull_leases_db_value);
 	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
 		DEBUG(1, ("leases_db_traverse_persist_fn: ndr_pull_lease failed\n"));
+		TALLOC_FREE(d);
 		return 0;
 	}
 
@@ -113,6 +114,7 @@ static int leases_db_traverse_persist_fn(struct db_record *rec, void *_state)
 			ndr_err = ndr_push_struct_blob(
 				&blob, d, d, (ndr_push_flags_fn_t)ndr_push_leases_db_value);
 			if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+				TALLOC_FREE(d);
 				smb_panic("ndr_push_leases_db failed");
 				return 0;
 			}
diff --git a/source3/locking/share_mode_lock.c b/source3/locking/share_mode_lock.c
index 84e6c0f..8263437 100644
--- a/source3/locking/share_mode_lock.c
+++ b/source3/locking/share_mode_lock.c
@@ -96,6 +96,7 @@ static int sml_traverse_persist_fn(struct db_record *rec, void *_state)
                 &blob, d, d, (ndr_pull_flags_fn_t)ndr_pull_share_mode_data);
         if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
                 DEBUG(1, ("sml_traverse_persist_fn: ndr_pull_share_mode_lock failed\n"));
+		TALLOC_FREE(d);
                 return 0;
         }
 
diff --git a/source3/smbd/close.c b/source3/smbd/close.c
index dc763b5..e738eed 100644
--- a/source3/smbd/close.c
+++ b/source3/smbd/close.c
@@ -664,11 +664,13 @@ static NTSTATUS close_normal_file(struct smb_request *req, files_struct *fsp,
 	if (close_type != SHUTDOWN_CLOSE) {
 		is_durable = false;
 	}
-/*
+
+#ifdef STRICT_RESILIENT_CHECKING
 	if ( fsp->op->global->resilient && !lp_smb2_leases() ) {
 		is_durable = false;
 	}
-*/
+#endif
+
 	if (is_durable) {
 		DATA_BLOB new_cookie = data_blob_null;
 
