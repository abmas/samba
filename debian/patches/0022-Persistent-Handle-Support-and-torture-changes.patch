From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Wed, 1 Jun 2016 17:00:06 -0400
Subject: Persistent Handle Support and torture changes.

---
 lib/torture/torture.h                  |   2 +
 source3/librpc/idl/open_files.idl      |   1 +
 source3/librpc/idl/smbXsrv.idl         |   2 +
 source3/locking/brlock.c               |  63 +++++++-
 source3/locking/locking.c              |  12 +-
 source3/locking/share_mode_lock.c      | 110 ++++++++++++-
 source3/smbd/close.c                   |   3 +-
 source3/smbd/durable.c                 |  45 +++---
 source3/smbd/files.c                   |  10 +-
 source3/smbd/globals.h                 |   7 +
 source3/smbd/server.c                  |  14 +-
 source3/smbd/smb2_create.c             |  34 +++-
 source3/smbd/smb2_negprot.c            |   8 +
 source3/smbd/smb2_tcon.c               |  14 ++
 source3/smbd/smbXsrv_open.c            | 102 +++++++++++-
 source3/wscript_build                  |   1 +
 source4/torture/smb2/durable_v2_open.c | 287 ++++++++++++++++++++++++++++++++-
 source4/torture/smbtorture.c           |  31 ++++
 18 files changed, 693 insertions(+), 53 deletions(-)

diff --git a/lib/torture/torture.h b/lib/torture/torture.h
index 356922a..028fe9f 100644
--- a/lib/torture/torture.h
+++ b/lib/torture/torture.h
@@ -101,6 +101,8 @@ struct torture_context
 
 	/** Loadparm context (will go away in favor of torture_setting_ at some point) */
 	struct loadparm_context *lp_ctx;
+
+        char *numeric_string;
 };
 
 struct torture_results
diff --git a/source3/librpc/idl/open_files.idl b/source3/librpc/idl/open_files.idl
index 6f74340..7628762 100644
--- a/source3/librpc/idl/open_files.idl
+++ b/source3/librpc/idl/open_files.idl
@@ -53,6 +53,7 @@ interface open_files
 		timeval		time;
 		file_id		id;
 		udlong		share_file_id;
+		udlong		open_persistent_id;
 		uint32		uid;
 		uint16		flags;
 		uint32		name_hash;
diff --git a/source3/librpc/idl/smbXsrv.idl b/source3/librpc/idl/smbXsrv.idl
index 5850b63..75a7520 100644
--- a/source3/librpc/idl/smbXsrv.idl
+++ b/source3/librpc/idl/smbXsrv.idl
@@ -384,6 +384,7 @@ interface smbXsrv
 		[ref] smbXsrv_tcon_global0		*global;
 		NTSTATUS				status;
 		NTTIME					idle_time;
+		uint32					capabilities;
 		[ignore] connection_struct		*compat;
 	} smbXsrv_tcon;
 
@@ -425,6 +426,7 @@ interface smbXsrv
 		uint32					durable_timeout_msec;
 		boolean8				durable;
                 boolean8                                resilient;
+                boolean8                                persistent;
 		DATA_BLOB				backend_cookie;
 	} smbXsrv_open_global0;
 
diff --git a/source3/locking/brlock.c b/source3/locking/brlock.c
index 3d529bc..d383f93 100644
--- a/source3/locking/brlock.c
+++ b/source3/locking/brlock.c
@@ -52,6 +52,9 @@ struct byte_range_lock {
 	struct db_record *record;
 };
 
+/* forward declaration */
+static int brl_traverse_persist_fn(struct db_record *rec, void *state);
+
 /****************************************************************************
  Debug info at level 10 for lock struct.
 ****************************************************************************/
@@ -345,12 +348,13 @@ void brl_init(bool read_only)
 {
 	int tdb_flags;
 	char *db_path;
+	NTSTATUS status;
 
 	if (brlock_db) {
 		return;
 	}
 
-	tdb_flags = TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH;
+	tdb_flags = TDB_DEFAULT|TDB_VOLATILE|/*TDB_CLEAR_IF_FIRST|*/TDB_INCOMPATIBLE_HASH;
 
 	if (!lp_clustering()) {
 		/*
@@ -377,6 +381,24 @@ void brl_init(bool read_only)
 		TALLOC_FREE(db_path);
 		return;
 	}
+
+	if ( read_only == false ) {
+		status = dbwrap_traverse(brlock_db, brl_traverse_persist_fn, NULL, NULL);
+		if ( ! NT_STATUS_IS_OK(status) ) {
+			TALLOC_FREE(brlock_db);
+			DEBUG(0,("brl_init: ERROR: Failed to recover persistent handle related brlock entries. Cleanup and proceed.\n"));
+			tdb_flags |= TDB_CLEAR_IF_FIRST;
+			brlock_db = db_open(NULL, db_path,
+                            		SMB_OPEN_DATABASE_TDB_HASH_SIZE, tdb_flags,
+                            		read_only?O_RDONLY:(O_RDWR|O_CREAT), 0644,
+                            		DBWRAP_LOCK_ORDER_2, DBWRAP_FLAG_NONE);
+			if (!brlock_db) {
+				DEBUG(0,("brl_init: Failed to open byte range locking database %s\n", db_path));
+				TALLOC_FREE(db_path);
+				return;
+			}
+		}
+	}
 	TALLOC_FREE(db_path);
 }
 
@@ -1649,7 +1671,7 @@ bool brl_mark_disconnected(struct files_struct *fsp)
 
 	smblctx = fsp->op->global->open_persistent_id;
 
-	if (!(fsp->op->global->durable || fsp->op->global->resilient)) {
+	if (!(fsp->op->global->durable || fsp->op->global->resilient || fsp->op->global->persistent)) {
 		return false;
 	}
 
@@ -1719,7 +1741,7 @@ bool brl_reconnect_disconnected(struct files_struct *fsp)
 
 	smblctx = fsp->op->global->open_persistent_id;
 
-	if (!(fsp->op->global->durable || fsp->op->global->resilient)) {
+	if (!(fsp->op->global->durable || fsp->op->global->resilient || fsp->op->global->persistent)) {
 		DEBUG(1, ("brl_reconnect_disconnected: durable not set\n"));
 		return false;
 	}
@@ -1841,6 +1863,41 @@ static int brl_traverse_fn(struct db_record *rec, void *state)
 	return 0;
 }
 
+static int brl_traverse_persist_fn(struct db_record *rec, void *state)
+{
+        struct lock_struct *locks;
+        bool found = false;
+        TDB_DATA value;
+	NTSTATUS status;
+
+        value = dbwrap_record_get_value(rec);
+
+        /* In a traverse function we must make a copy of
+           dbuf before modifying it. */
+
+        locks = (struct lock_struct *)talloc_memdup(
+                talloc_tos(), value.dptr, value.dsize);
+        if (!locks) {
+                return 0; /* best effort. next entry*/
+        }
+
+	found = smbXsrv_lookup_persistent_id(locks->context.smblctx);
+
+	if ( found == false) {
+		status = dbwrap_record_delete(rec);
+		if (!NT_STATUS_IS_OK(status)) {
+                	DEBUG(1, ("brl_traverse_persist_fn: Error deleting record for persistent id %lu\n", locks->context.smblctx));
+                	return 0; /*best effort, try to keep going*/
+        	}
+                DEBUG(1, ("brl_traverse_persist_fn: Deleted brl lock record for persistent id %lu\n", locks->context.smblctx));
+	} else {
+                DEBUG(1, ("brl_traverse_persist_fn: Retaining brl lock record for persistent id %lu\n", locks->context.smblctx));
+	}
+
+        TALLOC_FREE(locks);
+        return 0;
+}
+
 /*******************************************************************
  Call the specified function on each lock in the database.
 ********************************************************************/
diff --git a/source3/locking/locking.c b/source3/locking/locking.c
index 9936670..d6bdb71 100644
--- a/source3/locking/locking.c
+++ b/source3/locking/locking.c
@@ -846,6 +846,14 @@ bool set_share_mode(struct share_mode_lock *lck, struct files_struct *fsp,
 	e->time.tv_usec = fsp->open_time.tv_usec;
 	e->id = fsp->file_id;
 	e->share_file_id = fsp->fh->gen_id;
+	/* For persistent opens, record the persistent id as we will need it when reconnecting after a crash*/
+	/* Note that setting it here does not work for resilient handle for example, which can be made resilient */
+	/* using an ioctl. Persistent handle has to be requested at create time, so setting it here works. */
+	if ( 1 == fsp->op->global->persistent ) {
+		e->open_persistent_id = fsp->op->global->open_persistent_id;
+	} else {
+		e->open_persistent_id = UINT64_MAX;
+	}
 	e->uid = (uint32_t)uid;
 	e->flags = (fsp->posix_flags & FSP_POSIX_FLAGS_OPEN) ?
 		SHARE_MODE_FLAG_POSIX_OPEN : 0;
@@ -914,11 +922,11 @@ bool mark_share_mode_disconnected(struct share_mode_lock *lck,
 	if (fsp->op == NULL) {
 		return false;
 	}
-	if (!(fsp->op->global->durable || fsp->op->global->resilient)) {
+	if (!(fsp->op->global->durable || fsp->op->global->resilient || fsp->op->global->persistent)) {
 		return false;
 	}
 
-       while (e = find_share_mode_entry(lck, fsp)) {
+       while ((e = find_share_mode_entry(lck, fsp))) {
                foundone = true;
                DEBUG(10, ("Marking share mode entry disconnected for durable handle\n"));
                server_id_set_disconnected(&e->pid);
diff --git a/source3/locking/share_mode_lock.c b/source3/locking/share_mode_lock.c
index abec959..694fb6b 100644
--- a/source3/locking/share_mode_lock.c
+++ b/source3/locking/share_mode_lock.c
@@ -58,9 +58,89 @@
 /* the locking database handle */
 static struct db_context *lock_db;
 
+/* forward decl */
+static TDB_DATA unparse_share_modes(struct share_mode_data *d);
+
+static int sml_traverse_persist_fn(struct db_record *rec, void *_state)
+{
+        uint32_t i;
+        TDB_DATA key,data;
+        TDB_DATA value;
+        DATA_BLOB blob;
+        enum ndr_err_code ndr_err;
+        struct share_mode_data *d;
+        struct file_id fid;
+	bool found_persistent_open = False;
+	NTSTATUS status;
+
+        key = dbwrap_record_get_key(rec);
+        value = dbwrap_record_get_value(rec);
+
+	DEBUG(1, ("sml_traverse_persist_fn: Entering sml_traverse_persist_fn\n"));
+
+        /* Ensure this is a locking_key record. */
+        if (key.dsize != sizeof(fid)) {
+                return 0;
+        }
+        memcpy(&fid, key.dptr, sizeof(fid));
+
+        d = talloc(talloc_tos(), struct share_mode_data);
+        if (d == NULL) {
+                return 0;
+        }
+
+        blob.data = value.dptr;
+        blob.length = value.dsize;
+
+        ndr_err = ndr_pull_struct_blob_all(
+                &blob, d, d, (ndr_pull_flags_fn_t)ndr_pull_share_mode_data);
+        if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+                DEBUG(1, ("sml_traverse_persist_fn: ndr_pull_share_mode_lock failed\n"));
+                return 0;
+        }
+
+        for (i=0; i<d->num_share_modes; i++) {
+                struct share_mode_entry *entry = &d->share_modes[i];
+		if ( entry->open_persistent_id != UINT64_MAX && smbXsrv_lookup_persistent_id(entry->open_persistent_id) ) {
+                	entry->stale = false; /* [skip] in idl */
+                	entry->lease = &d->leases[entry->lease_idx];
+			found_persistent_open = True;
+			server_id_set_disconnected(&entry->pid);
+			entry->share_file_id = entry->open_persistent_id;
+               		d->modified = true;
+			DEBUG(1, ("sml_traverse_persist_fn: Found a persistent open, retaining record for id %ld\n", entry->open_persistent_id));
+		} else { 
+                	entry->stale = true; /* [skip] in idl */
+		}
+        }
+
+	if ( !found_persistent_open ) {
+		dbwrap_record_delete(rec);
+	} else {
+		data = unparse_share_modes(d);
+		if ( data.dptr != NULL ) {
+			status = dbwrap_record_store(d->record, data, TDB_REPLACE);
+			if (!NT_STATUS_IS_OK(status)) {
+				DEBUG(1, ("sml_traverse_persist_fn: store returned %s\n", nt_errstr(status)));
+			}
+		}
+	}
+
+        if (DEBUGLEVEL >= 3) {
+                DEBUG(3, ("sml_traverse_persist_fn: parse_share_modes:\n"));
+                NDR_PRINT_DEBUG(share_mode_data, d);
+        }
+
+        TALLOC_FREE(d);
+	DEBUG(1, ("sml_traverse_persist_fn: Leaving sml_traverse_persist_fn\n"));
+	
+        return 0;
+}
+
 static bool locking_init_internal(bool read_only)
 {
 	char *db_path;
+	NTSTATUS status;
 
 	brl_init(read_only);
 
@@ -72,17 +152,42 @@ static bool locking_init_internal(bool read_only)
 		return false;
 	}
 
+	/* open the lock db without clearing existing entries, first. Let's try to keep the persistent */
+	/* handle related entries. If something fails in the middle, we will get rid of the db and move on*/
 	lock_db = db_open(NULL, db_path,
 			  SMB_OPEN_DATABASE_TDB_HASH_SIZE,
-			  TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+			  TDB_DEFAULT|TDB_VOLATILE|/*TDB_CLEAR_IF_FIRST|*/TDB_INCOMPATIBLE_HASH,
 			  read_only?O_RDONLY:O_RDWR|O_CREAT, 0644,
 			  DBWRAP_LOCK_ORDER_1, DBWRAP_FLAG_NONE);
-	TALLOC_FREE(db_path);
 	if (!lock_db) {
 		DEBUG(0,("ERROR: Failed to initialise locking database\n"));
+		TALLOC_FREE(db_path);
 		return False;
 	}
 
+	if ( read_only == false ) {
+		/* Ashok: traverse the db and only get rid of entries not belonging to a persistent open */
+		status = dbwrap_traverse_read(lock_db, sml_traverse_persist_fn, NULL, NULL);
+
+		if ( ! NT_STATUS_IS_OK(status) ) {
+			TALLOC_FREE(lock_db);
+			/* Cleanup and move on */
+			DEBUG(0,("ERROR: Failed to recover persistent handle related lock entries. Cleanup and proceed.\n"));
+			lock_db = db_open(NULL, db_path,
+				SMB_OPEN_DATABASE_TDB_HASH_SIZE,
+				TDB_DEFAULT|TDB_VOLATILE|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+				read_only?O_RDONLY:O_RDWR|O_CREAT, 0644,
+				DBWRAP_LOCK_ORDER_1, DBWRAP_FLAG_NONE);
+			if (!lock_db) {
+				DEBUG(0,("ERROR: Failed to initialise locking database\n"));
+				TALLOC_FREE(db_path);
+				return False;
+			}
+		} else {
+			TALLOC_FREE(db_path);
+		}
+	}
+
 	if (!posix_locking_init(read_only))
 		return False;
 
@@ -900,7 +1005,6 @@ bool has_connected_share_mode(struct file_id fid)
 	unsigned n;
 	struct share_mode_data *data;
 	struct share_mode_lock *lck;
-	bool ok;
 
 	lck = get_existing_share_mode_lock(frame, fid);
 	if (lck == NULL) {
diff --git a/source3/smbd/close.c b/source3/smbd/close.c
index db004e0..40400e8 100644
--- a/source3/smbd/close.c
+++ b/source3/smbd/close.c
@@ -658,7 +658,7 @@ static NTSTATUS close_normal_file(struct smb_request *req, files_struct *fsp,
 	status = ntstatus_keeperror(status, tmp);
 
 	if (NT_STATUS_IS_OK(status) && fsp->op != NULL) {
-		is_durable = fsp->op->global->durable || fsp->op->global->resilient;
+		is_durable = fsp->op->global->durable || fsp->op->global->resilient || fsp->op->global->persistent;
 	}
 
 	if (close_type != SHUTDOWN_CLOSE) {
@@ -725,6 +725,7 @@ static NTSTATUS close_normal_file(struct smb_request *req, files_struct *fsp,
 		 */
 		fsp->op->global->durable = false;
 		fsp->op->global->resilient = false;
+		fsp->op->global->persistent = false;
 	}
 
 	if (fsp->print_file) {
diff --git a/source3/smbd/durable.c b/source3/smbd/durable.c
index 4f322a9..868e563 100644
--- a/source3/smbd/durable.c
+++ b/source3/smbd/durable.c
@@ -169,7 +169,7 @@ NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
 	}
 
 	if ((fsp_lease_type(fsp) & SMB2_LEASE_HANDLE) == 0) {
-            if ( fsp->op->global->durable ) {
+            if ( fsp->op->global->durable && !fsp->op->global->persistent) {
 		return NT_STATUS_NOT_SUPPORTED;
             } else {
 		DEBUG(3, ("vfs_default_durable_disconnect: Ignoring the fact that no lease held. Continuing with durable disconnect"));
@@ -240,9 +240,11 @@ NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
 		}
 	}
 	if ( lck == NULL ) {
-            if ( fsp->op->global->durable ) {
+            if ( fsp->op->global->durable && !fsp->op->global->persistent) {
 	        return NT_STATUS_NOT_SUPPORTED;
             } else {
+		/* Now that we have taken care of the durable case, I think this can be removed. For resilient and persistent, it is */
+		/* entirely legit to have no share mode locks on disconnect. If there are no locks to preserve, none will be preserved */
                 DEBUG(1, ("vfs_default_durable_disconnect: Ignoring share mode lock check and continuing with durable disconnect\n"));
             }
 	}
@@ -554,8 +556,8 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 				       files_struct **result,
 				       DATA_BLOB *new_cookie)
 {
-	struct share_mode_lock *lck;
-	struct share_mode_entry *e;
+	struct share_mode_lock *lck = NULL;
+	struct share_mode_entry *e = NULL;
 	struct files_struct *fsp = NULL;
 	NTSTATUS status;
 	bool ok;
@@ -638,24 +640,25 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	lck = get_existing_share_mode_lock(mem_ctx, file_id);
 
         if (lck == NULL) {
-                if ( op->global->durable ) {
-                       DEBUG(3, ("vfs_default_durable_reconnect: share-mode lock "
+                if ( op->global->durable && !op->global->persistent) {
+                       DEBUG(1, ("vfs_default_durable_reconnect: share-mode lock "
                                "not obtained from db\n"));
                        return NT_STATUS_OBJECT_NAME_NOT_FOUND;
                 } else {
-                       DEBUG(3, ("vfs_default_durable_reconnect: share-mode lock "
+                       DEBUG(1, ("vfs_default_durable_reconnect: share-mode lock "
                                "not obtained from db, Ignoring...\n"));
                        goto PROCEEDOPEN;
                 }
         }
 
         if (lck->data->num_share_modes == 0) {
-                if ( op->global->durable ) {
+                if ( op->global->durable && !op->global->persistent) {
                        DEBUG(1, ("vfs_default_durable_reconnect: Error: no share-mode "
                                "entry in existing share mode lock\n"));
                        TALLOC_FREE(lck);
                        return NT_STATUS_INTERNAL_DB_ERROR;
                 } else {
+			/* Ok to not have any share mode locks for resilient and persistent? */
                        DEBUG(1, ("vfs_default_durable_reconnect: Error: no share-mode "
                                "entry in existing share mode lock, Ignoring...\n"));
                        goto PROCEEDOPEN;
@@ -675,7 +678,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	        break;
         }
         if ( e == NULL ) {
-                DEBUG(3, ("vfs_default_durable_reconnect: denying durable reconnect as no share mode entries available to reconnect\n"));
+                DEBUG(1, ("vfs_default_durable_reconnect: denying durable reconnect as no share mode entries available to reconnect\n"));
                 TALLOC_FREE(lck);
                 return NT_STATUS_OBJECT_NAME_NOT_FOUND;
         }
@@ -683,7 +686,7 @@ NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
 	if ((e->access_mask & (FILE_WRITE_DATA|FILE_APPEND_DATA)) &&
 	    !CAN_WRITE(conn))
 	{
-		DEBUG(5, ("vfs_default_durable_reconnect: denying durable "
+		DEBUG(1, ("vfs_default_durable_reconnect: denying durable "
 			  "share[%s] is not writeable anymore\n",
 			  lp_servicename(talloc_tos(), SNUM(conn))));
 		TALLOC_FREE(lck);
@@ -702,14 +705,19 @@ PROCEEDOPEN:
 		return status;
 	}
 
-	fsp->fh->private_options = e->private_options;
 	fsp->fh->gen_id = smbXsrv_open_hash(op);
 	fsp->file_id = file_id;
 	fsp->file_pid = smb1req->smbpid;
 	fsp->vuid = smb1req->vuid;
-	fsp->open_time = e->time;
-	fsp->access_mask = e->access_mask;
-	fsp->share_access = e->share_access;
+
+        if (e != NULL) {
+		fsp->fh->private_options = e->private_options;
+		fsp->open_time = e->time;
+		fsp->access_mask = e->access_mask;
+		fsp->share_access = e->share_access;
+		fsp->oplock_type = e->op_type;
+	}
+
 	fsp->can_read = ((fsp->access_mask & (FILE_READ_DATA)) != 0);
 	fsp->can_write = ((fsp->access_mask & (FILE_WRITE_DATA|FILE_APPEND_DATA)) != 0);
 	fsp->fnum = op->local_id;
@@ -731,7 +739,6 @@ PROCEEDOPEN:
 	 * We do not support aio write behind for smb2
 	 */
 	fsp->aio_write_behind = false;
-	fsp->oplock_type = e->op_type;
 
 	if (fsp->oplock_type == LEASE_OPLOCK) {
 		struct share_mode_lease *l = &lck->data->leases[e->lease_idx];
@@ -779,9 +786,11 @@ PROCEEDOPEN:
 	op->compat = fsp;
 	fsp->op = op;
 
-	e->pid = messaging_server_id(conn->sconn->msg_ctx);
-	e->op_mid = smb1req->mid;
-	e->share_file_id = fsp->fh->gen_id;
+        if (e != NULL) {
+	        e->pid = messaging_server_id(conn->sconn->msg_ctx);
+	        e->op_mid = smb1req->mid;
+	        e->share_file_id = fsp->fh->gen_id;
+        }
 
 	ok = brl_reconnect_disconnected(fsp);
 	if (!ok) {
diff --git a/source3/smbd/files.c b/source3/smbd/files.c
index 47a18c4..7ecd0ab 100644
--- a/source3/smbd/files.c
+++ b/source3/smbd/files.c
@@ -156,17 +156,13 @@ void file_close_conn(connection_struct *conn)
 		if (fsp->conn != conn) {
 			continue;
 		}
-		if (fsp->op != NULL && fsp->op->global->durable) {
+		if (fsp->op != NULL) {
 			/*
-			 * A tree disconnect closes a durable handle
+			 * A tree disconnect closes a durable,resilient or persistent handle
 			 */
 			fsp->op->global->durable = false;
-		}
-		if (fsp->op != NULL && fsp->op->global->resilient) {
-			/*
-			 * A tree disconnect closes a resilient handle
-			 */
 			fsp->op->global->resilient = false;
+			fsp->op->global->persistent = false;
 		}
 		close_file(NULL, fsp, SHUTDOWN_CLOSE);
 	}
diff --git a/source3/smbd/globals.h b/source3/smbd/globals.h
index 4e1e8a2..1bc2cdc 100644
--- a/source3/smbd/globals.h
+++ b/source3/smbd/globals.h
@@ -547,6 +547,7 @@ NTSTATUS smb2srv_client_connection_pass(struct smbd_smb2_request *smb2req,
 NTSTATUS smbXsrv_connection_init_tables(struct smbXsrv_connection *conn,
 					enum protocol_types protocol);
 
+bool smbXsrv_lookup_persistent_id(uint64_t persistent_id_to_find);
 NTSTATUS smbXsrv_session_global_init(void);
 NTSTATUS smbXsrv_session_create(struct smbXsrv_connection *conn,
 				NTTIME now,
@@ -915,3 +916,9 @@ struct smbd_server_connection {
 extern struct smbXsrv_client *global_smbXsrv_client;
 
 void smbd_init_globals(void);
+
+struct smbXsrv_open_persistent_id {
+        struct smbXsrv_open_persistent_id *next;
+        uint64_t open_persistent_id;
+};
+
diff --git a/source3/smbd/server.c b/source3/smbd/server.c
index 42fcad6..a9d0096 100644
--- a/source3/smbd/server.c
+++ b/source3/smbd/server.c
@@ -1572,13 +1572,6 @@ extern void build_options(bool screen);
 		exit_daemon("Samba cannot init tcon context", EACCES);
 	}
 
-	if (!locking_init())
-		exit_daemon("Samba cannot init locking", EACCES);
-
-	if (!leases_db_init(false)) {
-		exit_daemon("Samba cannot init leases", EACCES);
-	}
-
 	if (!smbd_notifyd_init(msg_ctx, interactive)) {
 		exit_daemon("Samba cannot init notification", EACCES);
 	}
@@ -1631,6 +1624,13 @@ extern void build_options(bool screen);
 		exit_daemon("Samba cannot init global open", map_errno_from_nt_status(status));
 	}
 
+	if (!locking_init())
+		exit_daemon("Samba cannot init locking", EACCES);
+
+	if (!leases_db_init(false)) {
+		exit_daemon("Samba cannot init leases", EACCES);
+	}
+
 	/* This MUST be done before start_epmd() because otherwise
 	 * start_epmd() forks and races against dcesrv_ep_setup() to
 	 * call directory_create_or_exist() */
diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index 632dde9..d56ef62 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -475,6 +475,7 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 	struct smb2_create_blob *dh2q = NULL;
 	struct smb2_create_blob *rqls = NULL;
 	struct smbXsrv_open *op = NULL;
+	bool persistent_handle = false;
 
 	if(lp_fake_oplocks(SNUM(smb2req->tcon->compat))) {
 		requested_oplock_level = SMB2_OPLOCK_LEVEL_NONE;
@@ -785,6 +786,7 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 		if (dh2q) {
 			const uint8_t *p = dh2q->data.data;
 			uint32_t durable_v2_timeout = 0;
+			uint32_t durable_v2_flags = 0;
 			DATA_BLOB create_guid_blob;
 
 			if (dh2q->data.length != 32) {
@@ -798,6 +800,14 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			}
 
 			durable_v2_timeout = IVAL(p, 0);
+			durable_v2_flags = IVAL(p, 4);
+
+                        DEBUG(3, ("Got durable v2 request with flag  %x and tcon capability %x\n",
+                                           (int)durable_v2_flags, smb2req->tcon->capabilities));
+                        if ((durable_v2_flags & SMB2_DHANDLE_FLAG_PERSISTENT) && (smb2req->tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)) {
+                                DEBUG(3, ("Setting persistent_handle = true\n"));
+				persistent_handle = true;
+			}
 			create_guid_blob = data_blob_const(p + 16, 16);
 
 			status = GUID_from_ndr_blob(&create_guid_blob,
@@ -951,9 +961,9 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 
 			DEBUG(10, ("smb2_create_send: %s to recreate the "
 				   "smb2srv_open struct for a durable handle.\n",
-				   (op->global->durable || op->global->resilient) ? "succeded" : "failed"));
+                                   (op->global->durable || op->global->resilient || op->global->persistent) ? "succeded" : "failed"));
 
-			if (!(op->global->durable || op->global->resilient)) {
+                        if (!(op->global->durable || op->global->resilient || op->global->persistent)) {
 				talloc_free(op);
 				tevent_req_nterror(req,
 					NT_STATUS_OBJECT_NAME_NOT_FOUND);
@@ -1143,8 +1153,14 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			}
 		}
 
-		if (durable_requested &&
-		    (fsp_lease_type(result) & SMB2_LEASE_HANDLE))
+                /*
+                 *  Removed this check:
+                 *     (fsp_lease_type(result) & SMB2_LEASE_HANDLE)
+                 *  because persistent handles don't get that value and
+                 *  we need to create a cookie here.
+                 */
+
+		if (durable_requested)
 		{
 			status = SMB_VFS_DURABLE_COOKIE(result,
 						op,
@@ -1170,6 +1186,13 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			op->global->durable_timeout_msec = durable_timeout_msec;
 		}
 
+                if (persistent_handle) {
+                        op->global->durable = true;
+                        op->global->persistent = true;
+                        op->global->durable_timeout_msec = durable_timeout_msec;
+                        update_open = true;
+                }
+
 		if (update_open) {
 			op->global->create_guid = _create_guid;
 
@@ -1202,6 +1225,9 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			DATA_BLOB blob = data_blob_const(p, sizeof(p));
 			uint32_t durable_v2_response_flags = 0;
 
+			if ( persistent_handle ) 
+				durable_v2_response_flags = SMB2_DHANDLE_FLAG_PERSISTENT;
+
 			SIVAL(p, 0, op->global->durable_timeout_msec);
 			SIVAL(p, 4, durable_v2_response_flags);
 
diff --git a/source3/smbd/smb2_negprot.c b/source3/smbd/smb2_negprot.c
index 0bb13bc..b7dc32c 100644
--- a/source3/smbd/smb2_negprot.c
+++ b/source3/smbd/smb2_negprot.c
@@ -310,6 +310,14 @@ NTSTATUS smbd_smb2_request_process_negprot(struct smbd_smb2_request *req)
 		capabilities |= SMB2_CAP_ENCRYPTION;
 	}
 
+        /* Ashok: Advertise persistent handles capability */
+        if (protocol >= PROTOCOL_SMB3_00) {
+               if (in_capabilities & SMB2_CAP_PERSISTENT_HANDLES) {
+                       capabilities |= SMB2_CAP_PERSISTENT_HANDLES;
+		/*Ashok: Add setting connection datastructure flag for PH */
+               }
+        }
+
 	/*
 	 * 0x10000 (65536) is the maximum allowed message size
 	 * for SMB 2.0
diff --git a/source3/smbd/smb2_tcon.c b/source3/smbd/smb2_tcon.c
index 61e2a36..58f7cf5 100644
--- a/source3/smbd/smb2_tcon.c
+++ b/source3/smbd/smb2_tcon.c
@@ -329,6 +329,12 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 
 	tcon->status = NT_STATUS_OK;
 
+	if ((conn->smb2.client.capabilities & conn->smb2.server.capabilities & SMB2_CAP_PERSISTENT_HANDLES)) {
+		tcon->capabilities = SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY;
+	} else {
+		tcon->capabilities = 0; /* Currently CA is the only capability */
+	}
+
 	status = smbXsrv_tcon_update(tcon);
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(tcon);
@@ -377,6 +383,14 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 		*out_share_flags |= SMB2_SHAREFLAG_ENCRYPT_DATA;
 	}
 
+	/* If xconn (smbXsrv_connection ) has CAP_PERSISTENT setup, then
+	 * set the following */
+	if ( conn->protocol >= PROTOCOL_SMB3_00 && \
+		( tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY) ) {
+		*out_capabilities |= SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY;
+		
+	}
+
 	*out_maximal_access = tcon->compat->share_access;
 
 	*out_tree_id = tcon->global->tcon_wire_id;
diff --git a/source3/smbd/smbXsrv_open.c b/source3/smbd/smbXsrv_open.c
index cbe623f..bdcb8ba 100644
--- a/source3/smbd/smbXsrv_open.c
+++ b/source3/smbd/smbXsrv_open.c
@@ -31,6 +31,11 @@
 #include "librpc/gen_ndr/ndr_smbXsrv.h"
 #include "serverid.h"
 
+/* Remove the paranoid malloc checker. */
+#ifdef malloc
+#undef malloc
+#endif
+
 struct smbXsrv_open_table {
 	struct {
 		struct db_context *db_ctx;
@@ -46,10 +51,96 @@ struct smbXsrv_open_table {
 
 static struct db_context *smbXsrv_open_global_db_ctx = NULL;
 
+struct smbXsrv_open_persistent_id *smbXsrv_open_global_persistent_ids = NULL;
+
+static NTSTATUS smbXsrv_open_global_parse_record(TALLOC_CTX *mem_ctx,
+						 struct db_record *rec,
+						 struct smbXsrv_open_global0 **global);
+
+static int smbXsrv_open_global_traverse_persist_fn(struct db_record *rec, void *data)
+{
+        /**
+         *  Not using the state feature right now, so commenting this out
+	struct smbXsrv_open_global_traverse_state *state =
+            (struct smbXsrv_open_global_traverse_state*)data;
+        */
+
+	struct smbXsrv_open_global0 *global = NULL;
+	NTSTATUS status;
+
+	status = smbXsrv_open_global_parse_record(talloc_tos(), rec, &global);
+	if (!NT_STATUS_IS_OK(status)) {
+	        DEBUG(1, ("parse record failed on open_global\n"));
+		return -1;
+	}
+
+	global->db_rec = rec;
+        if (global->persistent == 1) {
+                struct smbXsrv_open_persistent_id *persistent_id_element = malloc(sizeof(struct smbXsrv_open_persistent_id));
+                struct smbXsrv_open_persistent_id *last_element = smbXsrv_open_global_persistent_ids;
+
+                persistent_id_element->next = NULL;
+                persistent_id_element->open_persistent_id = global->open_persistent_id;
+
+                if (last_element != NULL) {
+                       while (last_element->next != NULL) {
+		             last_element = last_element->next;
+                       }
+                       last_element->next = persistent_id_element;
+                } else {
+                       smbXsrv_open_global_persistent_ids = persistent_id_element;
+                }
+        } else {
+                status = dbwrap_record_delete(rec);
+	        if (!NT_STATUS_IS_OK(status)) {
+	                DEBUG(1, ("error when deleting non-persistent record\n"));
+         	}
+        }
+
+        /**
+         *  Not using the 'state' feature at the moment, so commenting it out                  
+	ret = state->fn(global, state->private_data);
+         */
+ 
+	talloc_free(global);
+	return 0;
+}
+
+bool smbXsrv_lookup_persistent_id(uint64_t persistent_id_to_find)
+{
+
+        struct smbXsrv_open_persistent_id *current_id;
+	if ( smbXsrv_open_global_db_ctx == NULL ) {
+		DEBUG(1,("smbXsrv_lookup_persistent_id with smbXsrv_open_global_db_ctx = NULL\n"));
+	}
+
+        if (smbXsrv_open_global_persistent_ids == NULL) {
+                return false;
+        }
+        current_id = smbXsrv_open_global_persistent_ids;
+        while (current_id != NULL) {
+                if (current_id->open_persistent_id == persistent_id_to_find) {
+                        return true;
+                }
+                current_id = current_id->next;
+        }
+        return false;
+}
+
 NTSTATUS smbXsrv_open_global_init(void)
 {
 	char *global_path = NULL;
 	struct db_context *db_ctx = NULL;
+	NTSTATUS status;
+
+        /**
+         *  Not using the 'state' feature at the moment, so commenting it out
+	int count = 0;
+	struct smbXsrv_open_global_traverse_state state = {
+		.fn = fn,
+		.private_data = private_data,
+	};
+        */
 
 	if (smbXsrv_open_global_db_ctx != NULL) {
 		return NT_STATUS_OK;
@@ -63,21 +154,22 @@ NTSTATUS smbXsrv_open_global_init(void)
 	db_ctx = db_open(NULL, global_path,
 			 0, /* hash_size */
 			 TDB_DEFAULT |
-			 TDB_CLEAR_IF_FIRST |
 			 TDB_INCOMPATIBLE_HASH,
 			 O_RDWR | O_CREAT, 0600,
 			 DBWRAP_LOCK_ORDER_1,
 			 DBWRAP_FLAG_NONE);
 	TALLOC_FREE(global_path);
 	if (db_ctx == NULL) {
-		NTSTATUS status;
-
+	        DEBUG(1, ("Null context on open_global\n"));
 		status = map_nt_error_from_unix_common(errno);
 
 		return status;
 	}
 
 	smbXsrv_open_global_db_ctx = db_ctx;
+	status = dbwrap_traverse_read(smbXsrv_open_global_db_ctx,
+				      smbXsrv_open_global_traverse_persist_fn,
+				      NULL, NULL);
 
 	return NT_STATUS_OK;
 }
@@ -998,7 +1090,7 @@ NTSTATUS smbXsrv_open_close(struct smbXsrv_open *op, NTTIME now)
 		}
 	}
 
-	if (global_rec != NULL && ((op->global->durable) || (op->global->resilient))) {
+        if (global_rec != NULL && ((op->global->durable) || (op->global->resilient) || (op->global->persistent))) {
 		/*
 		 * If it is a durable open we need to update the global part
 		 * instead of deleting it
@@ -1242,7 +1334,7 @@ NTSTATUS smb2srv_open_recreate(struct smbXsrv_connection *conn,
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
 
-	if (!((op->global->durable) || (op->global->resilient))) {
+        if (!((op->global->durable) || (op->global->resilient) || (op->global->persistent))) {
 		TALLOC_FREE(op);
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
diff --git a/source3/wscript_build b/source3/wscript_build
index a3cb7d2..7ecb0e0 100755
--- a/source3/wscript_build
+++ b/source3/wscript_build
@@ -648,6 +648,7 @@ bld.SAMBA3_SUBSYSTEM('LOCKING',
                     locking/posix.c
                     locking/share_mode_lock.c''',
                     deps='''
+		    smbd_base
                     tdb
                     talloc
                     LEASES_DB
diff --git a/source4/torture/smb2/durable_v2_open.c b/source4/torture/smb2/durable_v2_open.c
index 18dbc71..e3f749c 100644
--- a/source4/torture/smb2/durable_v2_open.c
+++ b/source4/torture/smb2/durable_v2_open.c
@@ -19,6 +19,8 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 #include <unistd.h>
+#include <dirent.h>
+#include <signal.h>
 #include "includes.h"
 #include "libcli/smb2/smb2.h"
 #include "libcli/smb2/smb2_calls.h"
@@ -314,10 +316,21 @@ static bool test_durable_v2_open_oplock_table(struct torture_context *tctx,
 {
 	bool ret = true;
 	uint8_t i;
+        int testnum = -1;
 
 	smb2_util_unlink(tree, fname);
 
+        if (tctx->numeric_string != NULL) {
+                testnum = atoi(tctx->numeric_string);
+        }
+
 	for (i = 0; i < num_tests; i++) {
+                if (testnum != -1) {
+                         if (testnum != i) {
+                               continue;
+                         }
+                }
+
 		ret = test_one_durable_v2_open_oplock(tctx,
 						      tree,
 						      fname,
@@ -1049,7 +1062,7 @@ bool test_durable_v2_open_reopen2_lease(struct torture_context *tctx,
 	options = tree->session->transport->options;
 
 	/* Choose a random name in case the state is left a little funky. */
-	snprintf(fname, 256, "durable_v2_open_reopen2_%s.dat",
+	snprintf(fname, 256, "durable_v2_open_reopen2_lease%s.dat",
 		 generate_random_str(tctx, 8));
 
 	smb2_util_unlink(tree, fname);
@@ -1295,7 +1308,7 @@ bool test_durable_v2_open_reopen2_lease_v2(struct torture_context *tctx,
 	options = tree->session->transport->options;
 
 	/* Choose a random name in case the state is left a little funky. */
-	snprintf(fname, 256, "durable_v2_open_reopen2_%s.dat",
+	snprintf(fname, 256, "durable_v2_open_reopen_leasev2_%s.dat",
 		 generate_random_str(tctx, 8));
 
 	smb2_util_unlink(tree, fname);
@@ -1530,7 +1543,7 @@ bool test_durable_v2_open_set_persistence(struct torture_context *tctx,
        struct GUID create_guid_1 = GUID_random();
 
        /* Choose a random name in case the state is left a little funky. */
-       snprintf(fname, 256, "durable_v2_open_persist_fsctl_%s.dat",
+       snprintf(fname, 256, "durable_v2_open_set_persist_%s.dat",
                 generate_random_str(tctx, 8));
 
        smb2_util_unlink(tree, fname);
@@ -1591,6 +1604,107 @@ done:
 }
 
 /*
+ * Test persistent open/disconnect/reconnect
+ */
+
+bool test_durable_v2_reopen_persistence(struct torture_context *tctx,
+                                         struct smb2_tree *tree)
+{
+       NTSTATUS status;
+       TALLOC_CTX *mem_ctx = talloc_new(tctx);
+       char fname[256];
+       struct smb2_handle _h1;
+       struct smb2_handle *h1 = NULL;
+       union smb_ioctl ioctl;
+       struct smb2_create io;
+       bool ret = true;
+       enum ndr_err_code ndr_ret;
+       struct GUID create_guid_1 = GUID_random();
+       struct smbcli_options options;
+
+       /* Choose a random name in case the state is left a little funky. */
+       snprintf(fname, 256, "durable_v2_reopen_persist_%s.dat",
+                generate_random_str(tctx, 8));
+
+       options = tree->session->transport->options;
+
+       smb2_util_unlink(tree, fname);
+
+       ZERO_STRUCT(break_info);
+       tree->session->transport->oplock.handler = torture_oplock_handler;
+       tree->session->transport->oplock.private_data = tree;
+
+       smb2_oplock_create_share(&io, fname,
+                                smb2_util_share_access(""),
+                                smb2_util_oplock_level("b"));
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = true;
+       io.in.persistent_open = true;
+       io.in.create_guid = create_guid_1;
+       io.in.timeout = 30000;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, true);
+       CHECK_VAL(io.out.persistent_open, true);
+
+       _h1 = io.out.file.handle;
+       h1 = &_h1;
+
+       /* disconnect, reconnect and then do durable reopen */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+                torture_warning(tctx, "couldn't reconnect, bailing\n");
+                ret = false;
+                goto done;
+       }
+
+       /*
+        * Now for a succeeding reconnect to our first session:
+        */
+       ZERO_STRUCT(io);
+       io.in.fname = fname;
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle_v2 = h1;
+       io.in.create_guid = create_guid_1;
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+
+       /* disconnect one more time */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+               torture_warning(tctx, "couldn't reconnect, bailing\n");
+               ret = false;
+               goto done;
+       }
+
+       status = smb2_util_close(tree, *h1);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       h1 = NULL;
+
+done:
+       if (h1 != NULL) {
+              smb2_util_close(tree, *h1);
+       }
+       smb2_util_close(tree, io.out.file.handle);
+
+       smb2_util_unlink(tree, fname);
+
+       talloc_free(mem_ctx);
+       return ret;
+}
+
+/*
  * Test resilient open, disconnect, re-connect
  */
 
@@ -2376,6 +2490,171 @@ bool test_persistent_open_lease(struct torture_context *tctx,
 	return ret;
 }
 
+bool test_persistent_samba_kill(struct torture_context *tctx,
+                                struct smb2_tree *tree)
+{
+       DIR* dir;
+       struct dirent* ent;
+       char* endptr;
+       char buf[512];
+       NTSTATUS status;
+       TALLOC_CTX *mem_ctx = talloc_new(tctx);
+       char fname[256];
+       struct smb2_handle _h1;
+       struct smb2_handle *h1 = NULL;
+       union smb_ioctl ioctl;
+       struct smb2_create io;
+       bool ret = true;
+       bool found_process = false;
+       enum ndr_err_code ndr_ret;
+       struct GUID create_guid_1 = GUID_random();
+       struct smbcli_options options;
+       struct smb2_lock lck;
+       struct smb2_lock_element lock[1];
+
+       /* Choose a random name in case the state is left a little funky. */
+       snprintf(fname, 256, "persist_samba_kill_%s.dat",
+                generate_random_str(tctx, 8));
+
+       options = tree->session->transport->options;
+
+       smb2_util_unlink(tree, fname);
+
+       ZERO_STRUCT(break_info);
+       tree->session->transport->oplock.handler = torture_oplock_handler;
+       tree->session->transport->oplock.private_data = tree;
+
+       smb2_oplock_create_share(&io, fname,
+                                smb2_util_share_access(""),
+                                smb2_util_oplock_level("b"));
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = true;
+       io.in.persistent_open = true;
+       io.in.create_guid = create_guid_1;
+       io.in.timeout = 30000;
+
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       _h1 = io.out.file.handle;
+       h1 = &_h1;
+
+       lock[0].offset = 0;
+       lock[0].length = 4;
+       lock[0].flags = SMB2_LOCK_FLAG_EXCLUSIVE;
+       ZERO_STRUCT(lck);
+       lck.in.file.handle = _h1;
+       lck.in.locks = &lock[0];
+       lck.in.lock_count = 1;
+       status = smb2_lock(tree, &lck);
+       torture_assert_ntstatus_ok(tctx, status, "Incorrect status");
+
+#ifdef WHATEVER
+       if (!(dir = opendir("/proc"))) {
+           return false;
+       }
+
+       while((ent = readdir(dir)) != NULL) {
+           /* if endptr is not a null character, the directory is not
+            * entirely numeric, so ignore it */
+	   FILE * fp = NULL;
+           long lpid = strtol(ent->d_name, &endptr, 10);
+           if (*endptr != '\0') {
+               continue;
+           }   
+
+           /* try to open the cmdline file */
+           snprintf(buf, sizeof(buf), "/proc/%ld/cmdline", lpid);
+           fp = fopen(buf, "r");
+        
+           if (fp) {
+               if (fgets(buf, sizeof(buf), fp) != NULL) {
+                   /* check the first token in the file, the program name */
+                   char* first = strtok(buf, " ");
+                   if (!strcmp(first, "smbd")) {
+                       fclose(fp);
+                       kill(lpid, SIGKILL);
+                       found_process = true;
+                       break;
+                   }
+               }
+               fclose(fp);
+           }   
+        
+       }
+    
+       closedir(dir);
+       if (!found_process) return false;
+#endif
+       system("/etc/init.d/samba restart");
+
+       /* disconnect, reconnect and then do persistent reopen */
+       TALLOC_FREE(tree);
+
+       sleep(20);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+                torture_warning(tctx, "couldn't reconnect, bailing\n");
+                ret = false;
+                goto done;
+       }
+
+       /*
+        * Now for a succeeding reconnect to our first session:
+        */
+       ZERO_STRUCT(io);
+       io.in.fname = fname;
+       io.in.durable_open = false;
+       io.in.durable_open_v2 = false;
+       io.in.persistent_open = false;
+       io.in.durable_handle_v2 = h1;
+       io.in.create_guid = create_guid_1;
+       status = smb2_create(tree, mem_ctx, &io);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       CHECK_CREATED(&io, EXISTED, FILE_ATTRIBUTE_ARCHIVE);
+       CHECK_VAL(io.out.durable_open, false);
+       CHECK_VAL(io.out.durable_open_v2, false); /* no dh2q response blob */
+       CHECK_VAL(io.out.persistent_open, false);
+
+       _h1 = io.out.file.handle;
+
+       lock[0].offset = 0;
+       lock[0].length = 4;
+       lock[0].flags = SMB2_LOCK_FLAG_UNLOCK;
+       ZERO_STRUCT(lck);
+       lck.in.file.handle = _h1;
+       lck.in.locks = &lock[0];
+       lck.in.lock_count = 1;
+       status = smb2_lock(tree, &lck);
+       CHECK_STATUS(status, NT_STATUS_OK);
+
+       /* disconnect one more time */
+       TALLOC_FREE(tree);
+
+       if (!torture_smb2_connection_ext(tctx, 0, &options, &tree)) {
+               torture_warning(tctx, "couldn't reconnect, bailing\n");
+               ret = false;
+               h1 = NULL;
+               goto done;
+       }
+
+       status = smb2_util_close(tree, *h1);
+       CHECK_STATUS(status, NT_STATUS_FILE_CLOSED);
+       h1 = NULL;
+
+done:
+       if (h1 != NULL) {
+              smb2_util_close(tree, *h1);
+       }
+       smb2_util_close(tree, io.out.file.handle);
+
+       smb2_util_unlink(tree, fname);
+
+       talloc_free(mem_ctx);
+       return ret;
+}
+
 struct torture_suite *torture_smb2_durable_v2_open_init(void)
 {
 	struct torture_suite *suite =
@@ -2397,6 +2676,8 @@ struct torture_suite *torture_smb2_durable_v2_open_init(void)
 	torture_suite_add_1smb2_test(suite, "persistent-open-set-persistent", test_durable_v2_open_set_persistence);
         torture_suite_add_1smb2_test(suite, "resilience", test_durable_v2_resilience);
         torture_suite_add_1smb2_test(suite, "resilience-brlock", test_durable_v2_resilience_brlock);
+        torture_suite_add_1smb2_test(suite, "persistent-reopen", test_durable_v2_reopen_persistence);
+        torture_suite_add_1smb2_test(suite, "persistent-samba-kill", test_persistent_samba_kill);
 	suite->description = talloc_strdup(suite, "SMB2-DURABLE-V2-OPEN tests");
 
 	return suite;
diff --git a/source4/torture/smbtorture.c b/source4/torture/smbtorture.c
index fc50436..c85a874 100644
--- a/source4/torture/smbtorture.c
+++ b/source4/torture/smbtorture.c
@@ -97,9 +97,35 @@ static bool run_matching(struct torture_context *torture,
 
 	for (t = suite->testcases; t; t = t->next) {
 		char *name = talloc_asprintf(torture, "%s.%s", prefix, t->name);
+                char *dot_ptr = NULL;
+                char *numeric_ptr = NULL;
+                bool isdigit = false;
+
+                dot_ptr = strrchr(expr, '.');
+                if (dot_ptr != NULL) {
+                    numeric_ptr = dot_ptr + 1;
+                    while (numeric_ptr[0] != 0) {
+                       if (isdigit(numeric_ptr[0]) == 0) {
+                           isdigit = false;
+                           break;
+                       } else {
+                           isdigit = true;
+                           numeric_ptr++;
+                       }
+                    }
+                    if (isdigit) {
+                       *dot_ptr = 0;
+                    }
+                }
+
 		if (gen_fnmatch(expr, name) == 0) {
 			*matched = true;
 			reload_charcnv(torture->lp_ctx);
+                        if (isdigit) {
+                             torture->numeric_string = dot_ptr + 1;
+                        } else {
+                             torture->numeric_string = NULL;
+                        }
 			ret &= torture_run_tcase_restricted(torture, t, restricted);
 		}
 		for (p = t->tests; p; p = p->next) {
@@ -110,6 +136,11 @@ static bool run_matching(struct torture_context *torture,
 				ret &= torture_run_test_restricted(torture, t, p, restricted);
 			}
 		}
+
+                if (isdigit) {
+                   *dot_ptr = '.';
+                }
+
 	}
 
 	return ret;
