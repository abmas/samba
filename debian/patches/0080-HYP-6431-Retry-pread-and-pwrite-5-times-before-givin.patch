From: Ashok Ramakrishnan <ashok.ramakrishnan@simplivity.com>
Date: Tue, 27 Mar 2018 21:00:54 -0400
Subject: HYP-6431: Retry pread and pwrite 5 times before giving up. This
 helps when svtfs takes longer to activate hive.

Some added debugging to investigate HYP-3653.
---
 source3/lib/asys/asys.c | 21 +++++++++++++++++----
 source3/smbd/open.c     |  4 +++-
 2 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/source3/lib/asys/asys.c b/source3/lib/asys/asys.c
index 906d8cf..0a663d9 100644
--- a/source3/lib/asys/asys.c
+++ b/source3/lib/asys/asys.c
@@ -1,6 +1,9 @@
 /*
  * Async syscalls
  * Copyright (C) Volker Lendecke 2012
+ *  Copyright Â© Hewlett Packard Enterprise Development LP 2018
+ *  Contributors - Ashok Ramakrishnan (HPE) and Paul Cerqua (HPE)
+ *  Added support for Hyper-V over SMB 3.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -188,8 +191,13 @@ static void asys_pwrite_do(void *private_data)
 {
 	struct asys_job *job = (struct asys_job *)private_data;
 	struct asys_pwrite_args *args = &job->args.pwrite_args;
-
-	job->ret = pwrite(args->fildes, args->buf, args->nbyte, args->offset);
+	int i;
+	/* retry the write x times, with 1 second sleep if there is any error */
+	for (i=0; i<5; i++) {
+		job->ret = pwrite(args->fildes, args->buf, args->nbyte, args->offset);
+		if (job->ret >= 0) break;
+		sleep(1);
+	}
 	if (job->ret == -1) {
 		job->err = errno;
 	}
@@ -230,8 +238,13 @@ static void asys_pread_do(void *private_data)
 {
 	struct asys_job *job = (struct asys_job *)private_data;
 	struct asys_pread_args *args = &job->args.pread_args;
-
-	job->ret = pread(args->fildes, args->buf, args->nbyte, args->offset);
+	int i;
+	/* Try the read x times, with 1 second sleep before giving up. */
+	for (i = 0; i < 5; i++) {
+		job->ret = pread(args->fildes, args->buf, args->nbyte, args->offset);
+		if (job->ret >= 0 ) break;
+		sleep(1);
+	}
 	if (job->ret == -1) {
 		job->err = errno;
 	}
diff --git a/source3/smbd/open.c b/source3/smbd/open.c
index 13c2da3..eb950da 100644
--- a/source3/smbd/open.c
+++ b/source3/smbd/open.c
@@ -1776,7 +1776,7 @@ static NTSTATUS grant_fsp_oplock_type(struct smb_request *req,
 	}
 
 	if (lp_locking(fsp->conn->params) && file_has_brlocks(fsp)) {
-		DEBUG(1,("grant_fsp_oplock_type: file %s has byte range locks. granting only SMB2_LEASE_READ\n",
+		DEBUG(1,("grant_fsp_oplock_type: file %s has byte range locks. Clearing read lease\n",
 			fsp_str_dbg(fsp)));
 		granted &= ~SMB2_LEASE_READ;
 	}
@@ -1793,6 +1793,7 @@ static NTSTATUS grant_fsp_oplock_type(struct smb_request *req,
 			/*
 			 * Can grant only one writer
 			 */
+			DEBUG(1,("grant_fsp_oplock_type: Write lease exists, cannot grant. Clearing.\n"));
 			granted &= ~SMB2_LEASE_WRITE;
 		}
 
@@ -1813,6 +1814,7 @@ static NTSTATUS grant_fsp_oplock_type(struct smb_request *req,
 			lp_level2_oplocks(SNUM(fsp->conn));
 
 		if (!allow_level2) {
+			DEBUG(1,("grant_fsp_oplock_type: Client capability prevents lease. Granting no lease\n"));
 			granted = SMB2_LEASE_NONE;
 		}
 	}
