From: Kevin Pease <kevin.pease@simplivity.com>
Date: Mon, 7 Mar 2016 10:29:40 -0500
Subject: Add support for persistent handles.

Currently we just claim support, nothing is done to actually persist the
handle info.
---
 source3/smbd/smb2_create.c  | 7 +++++++
 source3/smbd/smb2_negprot.c | 7 +++++++
 source3/smbd/smb2_tcon.c    | 6 ++++++
 3 files changed, 20 insertions(+)

diff --git a/source3/smbd/smb2_create.c b/source3/smbd/smb2_create.c
index 3627cfd..9cb7197 100644
--- a/source3/smbd/smb2_create.c
+++ b/source3/smbd/smb2_create.c
@@ -670,6 +670,7 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 		struct GUID *create_guid = NULL;
 		bool update_open = false;
 		bool durable_requested = false;
+		bool persistent_handle_requested = false;
 		uint32_t durable_timeout_msec = 0;
 		bool do_durable_reconnect = false;
 		uint64_t persistent_id = 0;
@@ -785,6 +786,7 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 		if (dh2q) {
 			const uint8_t *p = dh2q->data.data;
 			uint32_t durable_v2_timeout = 0;
+			uint32_t durable_v2_flags = 0;
 			DATA_BLOB create_guid_blob;
 
 			if (dh2q->data.length != 32) {
@@ -798,6 +800,11 @@ static struct tevent_req *smbd_smb2_create_send(TALLOC_CTX *mem_ctx,
 			}
 
 			durable_v2_timeout = IVAL(p, 0);
+			durable_v2_flags = IVAL(p, 1);
+
+			if (durable_v2_flags | SMB2_DHANDLE_FLAG_PERSISTENT ) {
+				persistent_handle_requested = true;
+			}
 			create_guid_blob = data_blob_const(p + 16, 16);
 
 			status = GUID_from_ndr_blob(&create_guid_blob,
diff --git a/source3/smbd/smb2_negprot.c b/source3/smbd/smb2_negprot.c
index 0bb13bc..1146813 100644
--- a/source3/smbd/smb2_negprot.c
+++ b/source3/smbd/smb2_negprot.c
@@ -310,6 +310,13 @@ NTSTATUS smbd_smb2_request_process_negprot(struct smbd_smb2_request *req)
 		capabilities |= SMB2_CAP_ENCRYPTION;
 	}
 
+        /* Ashok: Advertise persistent handles capability */
+        if (protocol >= PROTOCOL_SMB3_00) {
+               if (in_capabilities & SMB2_CAP_PERSISTENT_HANDLES) {
+                       capabilities |= SMB2_CAP_PERSISTENT_HANDLES;
+               }
+        }
+
 	/*
 	 * 0x10000 (65536) is the maximum allowed message size
 	 * for SMB 2.0
diff --git a/source3/smbd/smb2_tcon.c b/source3/smbd/smb2_tcon.c
index 61e2a36..8072ea6 100644
--- a/source3/smbd/smb2_tcon.c
+++ b/source3/smbd/smb2_tcon.c
@@ -377,6 +377,12 @@ static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
 		*out_share_flags |= SMB2_SHAREFLAG_ENCRYPT_DATA;
 	}
 
+	/* Ashok SVT hack: Just clain CA capability and Scaleout */
+	if ( conn->protocol >= PROTOCOL_SMB3_00) {
+		*out_capabilities |= SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY;
+		*out_capabilities |= SMB2_SHARE_CAP_SCALEOUT;
+	}
+
 	*out_maximal_access = tcon->compat->share_access;
 
 	*out_tree_id = tcon->global->tcon_wire_id;
